<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Binary Lyf</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yufengli.cn/"/>
  <updated>2018-06-06T08:53:00.127Z</updated>
  <id>http://www.yufengli.cn/</id>
  
  <author>
    <name>bnyf</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>博弈论的三个小游戏&#39;:&#39; Bash游戏 威佐夫游戏 Nim游戏</title>
    <link href="http://www.yufengli.cn/2018/06/06/%E5%8D%9A%E5%BC%88%E8%AE%BA%E7%9A%84%E4%B8%89%E4%B8%AA%E5%B0%8F%E6%B8%B8%E6%88%8F/"/>
    <id>http://www.yufengli.cn/2018/06/06/博弈论的三个小游戏/</id>
    <published>2018-06-06T08:25:28.000Z</published>
    <updated>2018-06-06T08:53:00.127Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Bash游戏"><a href="#Bash游戏" class="headerlink" title="Bash游戏"></a>Bash游戏</h2><h3 id="题目链接"><a href="#题目链接" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1066" target="_blank" rel="noopener">https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1066</a></p><h3 id="游戏规则"><a href="#游戏规则" class="headerlink" title="游戏规则"></a>游戏规则</h3><p>有一堆石子一共N个，两人轮流拿，最少拿1个，最多拿K个，最后拿完石子的获胜。</p><h3 id="证明"><a href="#证明" class="headerlink" title="证明"></a>证明</h3><p>如果N % (k+1) == 0，B必胜，<br>否则A必胜</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(name,value) memset(name,value,sizeof(name))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span>(t--)&#123;</span><br><span class="line">        <span class="keyword">int</span> n,k;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; k;</span><br><span class="line">        <span class="keyword">if</span>(n % (k+<span class="number">1</span>) == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="威佐夫游戏"><a href="#威佐夫游戏" class="headerlink" title="威佐夫游戏"></a>威佐夫游戏</h2><h3 id="题目链接-1"><a href="#题目链接-1" class="headerlink" title="题目链接"></a>题目链接</h3><p><a href="https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1072#" target="_blank" rel="noopener">https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1072</a></p><h3 id="游戏规则-1"><a href="#游戏规则-1" class="headerlink" title="游戏规则"></a>游戏规则</h3><p>有两堆石子，两个人轮流从中取石子，可以从其中一堆中取不少于一个的石子或者从两堆石子中取相同的石子，最后把石子取完的人获胜。</p><h3 id="证明-1"><a href="#证明-1" class="headerlink" title="证明"></a>证明</h3><p>后手胜利的情况为：<br>(1, 2)<br>(3, 5)<br>(4, 7)<br>(6, 10)<br>(8, 13)<br>(9, 15)<br>(11, 18)<br>(12, 20)<br>。。。。。。<br>令 m = (1 + sqrt(5))/2  (黄金分割数+1 = 1.618)<br>观察发现每队整数之差为k，ak = [k<em>m] , bk = ak+k。<br>因此只要判断  [(bk-ak)</em>m]  是否== ak就可以了 </p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(name,value) memset(name,value,sizeof(name))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ak, bk;</span><br><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    x = (<span class="number">1</span> + <span class="built_in">sqrt</span>(<span class="number">5.0</span>)) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;ak, &amp;bk);</span><br><span class="line">        <span class="keyword">if</span>(ak &gt; bk) swap(ak,bk);</span><br><span class="line">        <span class="keyword">int</span> k = bk - ak;</span><br><span class="line">        <span class="keyword">if</span>(ak == (<span class="keyword">int</span>)(k * x)) <span class="built_in">printf</span>(<span class="string">"B\n"</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">printf</span>(<span class="string">"A\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Nim游戏"><a href="#Nim游戏" class="headerlink" title="Nim游戏"></a>Nim游戏</h2><p>###题目链接<br><a href="https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1069" target="_blank" rel="noopener">https://www.51nod.com/onlineJudge/questionCode.html#!problemId=1069</a></p><p>###游戏规则<br>有N堆石子。A B两个人轮流拿，A先拿。每次只能从一堆中取若干个，可将一堆全取走，但不可不取，拿到最后1颗石子的人获胜。假设A B都非常聪明，拿石子的过程中不会出现失误。给出N及每堆石子的数量，问最后谁能赢得比赛。<br>例如：3堆石子，每堆1颗。A拿1颗，B拿1颗，此时还剩1堆，所以A可以拿到最后1颗石子。</p><p>此题有个很奇妙的公式就是,如果n堆石子的个数满足 A0^A1^A2……An == 0,则B获胜，否则A获胜。</p><p>###证明<br>如果 A0^A1^A2……An  == K！= 0，n堆石子中一定存在一堆石子m，Am的最高位&gt;=  k，那么A一定可以从A堆中取出一定的石子使得K == 0。<br>而当K == 0且游戏没结束时，无论B取出多少个石子，K恒!= 0，故A必胜。<br>如果A0^A1^A2……An == 0时，由于A先取，由上述可知B必胜。</p><p>###代码</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mem(name,value) memset(name,value,sizeof(name))</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">105</span>;</span><br><span class="line"><span class="keyword">int</span> dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d"</span>,&amp;x);</span><br><span class="line">        sum ^= x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(sum == <span class="number">0</span>) <span class="built_in">cout</span> &lt;&lt; <span class="string">"B"</span> &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="built_in">cout</span> &lt;&lt; <span class="string">"A"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Bash游戏&quot;&gt;&lt;a href=&quot;#Bash游戏&quot; class=&quot;headerlink&quot; title=&quot;Bash游戏&quot;&gt;&lt;/a&gt;Bash游戏&lt;/h2&gt;&lt;h3 id=&quot;题目链接&quot;&gt;&lt;a href=&quot;#题目链接&quot; class=&quot;headerlink&quot; title=&quot;题
      
    
    </summary>
    
      <category term="计算机" scheme="http://www.yufengli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="数据结构与算法" scheme="http://www.yufengli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="博弈" scheme="http://www.yufengli.cn/tags/%E5%8D%9A%E5%BC%88/"/>
    
      <category term="ACM-ICPC" scheme="http://www.yufengli.cn/tags/ACM-ICPC/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.824 Lab1-MapReduce</title>
    <link href="http://www.yufengli.cn/2018/06/06/mit6-824-lab1/"/>
    <id>http://www.yufengli.cn/2018/06/06/mit6-824-lab1/</id>
    <published>2018-06-06T06:26:25.000Z</published>
    <updated>2018-06-06T07:35:20.893Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MIT6.824 是我在学习一些分布式系统方面的知识的时候偶然看到的，然后就开始尝试跟课。不得不说，国外的课程难度是真的大，一周的时间居然要学一门 Go 语言，然后还要读论文，进而做MapReduce 实验。<br>由于 MR（MapReduce） 框架需要建立在 DFS（Distributed File System）的基础上实现，所以本实验是通过使用<strong>多线程</strong>来模拟分布式环境。虽然难度上大大降低，但是通过该实验，还是会让我们对 MR 的核心原理有一个较为深刻的认识。<br>做实验之前我们需要先把经典的 MapReduce 论文给看了，窝比较建议直接看英文原文，但如果时间不充裕的话，可以直接在网上找中文的翻译版。<br>刚开始做这个实验的时候真的是一头雾水，完全不知道如何下手。后来发现这个工程有一个<strong>自动化测试文件（test_test.go）</strong>,每部分实验都会使用这个测试文件里的函数对代码进行测试。我们只要顺着这个测试函数逐步倒推，然后补全代码即可。       </p><h2 id="Part-I-Map-Reduce-input-and-output"><a href="#Part-I-Map-Reduce-input-and-output" class="headerlink" title="Part I: Map/Reduce input and output"></a>Part I: Map/Reduce input and output</h2><p>第一部分是先实现一个顺序版（sequential）的MR，让我们对 MR 的流程有一个大体的认识,并且实现<code>doMap()</code> 和 <code>doReduce()</code> 两个函数。<br>其包含两个测试函数<code>TestSequentialSingle()</code> 和 <code>TestSequentialMany()</code>。</p><h3 id="TestSequentialSingle"><a href="#TestSequentialSingle" class="headerlink" title="TestSequentialSingle()"></a>TestSequentialSingle()</h3><p>每个map worker处理一个文件，所以map worker的数量就等于文件的数量。<br>测试单个map worker 和 reduce worker。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSequentialSingle</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">mr := Sequential(<span class="string">"test"</span>, makeInputs(<span class="number">1</span>), <span class="number">1</span>, MapFunc, ReduceFunc)</span><br><span class="line">mr.Wait()</span><br><span class="line">check(t, mr.files)</span><br><span class="line">checkWorker(t, mr.stats)</span><br><span class="line">cleanup(mr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="TestSequentialMany（）"><a href="#TestSequentialMany（）" class="headerlink" title="TestSequentialMany（）"></a>TestSequentialMany（）</h3><p>此测试函数测试多个 map worker 和多个 reduce worker。<br>其运行逻辑和<code>TestSequentialSingle</code>类似。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSequentialMany</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">mr := Sequential(<span class="string">"test"</span>, makeInputs(<span class="number">5</span>), <span class="number">3</span>, MapFunc, ReduceFunc)</span><br><span class="line">mr.Wait()</span><br><span class="line">check(t, mr.files)</span><br><span class="line">checkWorker(t, mr.stats)</span><br><span class="line">cleanup(mr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Sequential"><a href="#Sequential" class="headerlink" title="Sequential()"></a>Sequential()</h3><p>测试函数将<code>工作名称，测试文件，reduce 的数量，用户定义的 map 函数，reduce 函数</code>五个实参传递给<code>Sequential()</code></p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sequential runs map and reduce tasks sequentially, waiting for each task to</span></span><br><span class="line"><span class="comment">// complete before running the next.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sequential</span><span class="params">(jobName <span class="keyword">string</span>, files []<span class="keyword">string</span>, nreduce <span class="keyword">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">mapF <span class="keyword">func</span>(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span>,</span></span><br><span class="line"><span class="function"><span class="title">reduceF</span> <span class="title">func</span><span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>)</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function">) <span class="params">(mr *Master)</span></span> &#123;</span><br><span class="line">mr = newMaster(<span class="string">"master"</span>)</span><br><span class="line"><span class="keyword">go</span> mr.run(jobName, files, nreduce, <span class="function"><span class="keyword">func</span><span class="params">(phase jobPhase)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> phase &#123;</span><br><span class="line"><span class="keyword">case</span> mapPhase:</span><br><span class="line"><span class="keyword">for</span> i, f := <span class="keyword">range</span> mr.files &#123;</span><br><span class="line">doMap(mr.jobName, i, f, mr.nReduce, mapF)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> reducePhase:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; mr.nReduce; i++ &#123;</span><br><span class="line">doReduce(mr.jobName, i, mergeName(mr.jobName, i), <span class="built_in">len</span>(mr.files), reduceF)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">mr.stats = []<span class="keyword">int</span>&#123;<span class="built_in">len</span>(files) + nreduce&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">`Sequential()`</span>首先获取一个<span class="string">`Master`</span>对象的指针，然后利用函数闭包运行<span class="string">`Master.run()`</span>。</span><br></pre></td></tr></table></figure><h3 id="Master-run"><a href="#Master-run" class="headerlink" title="Master.run()"></a>Master.run()</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// run executes a mapreduce job on the given number of mappers and reducers.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// First, it divides up the input file among the given number of mappers, and</span></span><br><span class="line"><span class="comment">// schedules each task on workers as they become available. Each map task bins</span></span><br><span class="line"><span class="comment">// its output in a number of bins equal to the given number of reduce tasks.</span></span><br><span class="line"><span class="comment">// Once all the mappers have finished, workers are assigned reduce tasks.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When all tasks have been completed, the reducer outputs are merged,</span></span><br><span class="line"><span class="comment">// statistics are collected, and the master is shut down.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note that this implementation assumes a shared file system.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mr *Master)</span> <span class="title">run</span><span class="params">(jobName <span class="keyword">string</span>, files []<span class="keyword">string</span>, nreduce <span class="keyword">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">schedule <span class="keyword">func</span>(phase jobPhase)</span>,</span></span><br><span class="line"><span class="function"><span class="title">finish</span> <span class="title">func</span><span class="params">()</span>,</span></span><br><span class="line"><span class="function">)</span> &#123;</span><br><span class="line">mr.jobName = jobName</span><br><span class="line">mr.files = files</span><br><span class="line">mr.nReduce = nreduce</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%s: Starting Map/Reduce task %s\n"</span>, mr.address, mr.jobName)</span><br><span class="line"></span><br><span class="line">schedule(mapPhase)</span><br><span class="line">schedule(reducePhase)</span><br><span class="line">finish()</span><br><span class="line">mr.merge()</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%s: Map/Reduce task completed\n"</span>, mr.address)</span><br><span class="line"></span><br><span class="line">mr.doneChannel &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="doMap"><a href="#doMap" class="headerlink" title="doMap()"></a>doMap()</h3><p><code>doMap()</code> 和 <code>doReduce()</code>是需要我们去实现的函数。<br><code>doMap()</code>的实现主要是将用户定义的<code>MapFunc()</code>切割的文本，通过 hash 分到 ‘nReduce’个切片中去。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doMap</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">jobName <span class="keyword">string</span>, // the name of the MapReduce job</span></span></span><br><span class="line"><span class="function"><span class="params">mapTaskNumber <span class="keyword">int</span>, // which <span class="keyword">map</span> task this is</span></span></span><br><span class="line"><span class="function"><span class="params">inFile <span class="keyword">string</span>,</span></span></span><br><span class="line">nReduce int, // the number of reduce task that will be run ("R" in the paper)</span><br><span class="line">mapF <span class="function"><span class="keyword">func</span><span class="params">(file <span class="keyword">string</span>, contents <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span>,</span></span><br><span class="line"><span class="function">)</span> &#123;</span><br><span class="line"><span class="comment">// read contents from 'infile'</span></span><br><span class="line">dat,err := ioutil.ReadFile(inFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"doMap: readFile "</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//transfer data into ‘kvSlice’ according to the mapF()</span></span><br><span class="line">kvSlice := mapF(inFile, <span class="keyword">string</span>(dat))</span><br><span class="line"></span><br><span class="line"><span class="comment">//divide the ‘kvSlice’ into 'reduceKv' according to the ihash()</span></span><br><span class="line"><span class="keyword">var</span> reduceKv [][]KeyValue <span class="comment">// temporary variable which will be written into reduce files</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;nReduce;i++ &#123;</span><br><span class="line">s1 := <span class="built_in">make</span>([]KeyValue,<span class="number">0</span>)</span><br><span class="line">reduceKv = <span class="built_in">append</span>(reduceKv, s1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _,kv := <span class="keyword">range</span> kvSlice&#123;</span><br><span class="line">hash := ihash(kv.Key) % nReduce</span><br><span class="line">reduceKv[hash] = <span class="built_in">append</span>(reduceKv[hash],kv)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//write 'reduceKv' into ‘nReduce’ JSON files</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i&lt;nReduce;i++ &#123;</span><br><span class="line">file,err := os.Create(reduceName(jobName,mapTaskNumber,i))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"doMap: create "</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enc := json.NewEncoder(file)</span><br><span class="line"><span class="keyword">for</span> _, kv := <span class="keyword">range</span> reduceKv[i]&#123;</span><br><span class="line">err := enc.Encode(&amp;kv)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"doMap: json encodem "</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file.Close()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### doReduce()</span></span><br><span class="line"><span class="string">`</span>doReduce()<span class="string">`主要是将 key 值相同的 value 打包发送给用户定义的 `</span>ReduceFunc()<span class="string">`，获得一个新的 kv对，key 值不变，而value值则是`</span>ReduceFunc()<span class="string">`的返回值，排序，最后将新的 kv对 切片写入文件。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>golang</span><br><span class="line"><span class="keyword">type</span> ByKey []KeyValue</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByKey)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByKey)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123; a[i],a[j] = a[j],a[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByKey)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i].Key &lt; a[j].Key &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doReduce</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">jobName <span class="keyword">string</span>, // the name of the whole MapReduce job</span></span></span><br><span class="line"><span class="function"><span class="params">reduceTaskNumber <span class="keyword">int</span>, // which reduce task this is</span></span></span><br><span class="line"><span class="function"><span class="params">outFile <span class="keyword">string</span>, // write the output here</span></span></span><br><span class="line">nMap int, // the number of map tasks that were run ("M" in the paper)</span><br><span class="line">reduceF <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function">)</span> &#123;</span><br><span class="line"><span class="comment">//read kv slice from the json file</span></span><br><span class="line"><span class="keyword">var</span> kvSlice []KeyValue</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i&lt;nMap;i++&#123;</span><br><span class="line"><span class="comment">//file, _ := os.OpenFile(reduceName(jobName,i,reduceTaskNumber), os.O_RDONLY, 0666)</span></span><br><span class="line">file,err := os.Open(reduceName(jobName,i,reduceTaskNumber))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"doReduce: open "</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> kv KeyValue</span><br><span class="line">dec := json.NewDecoder(file)</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">err := dec.Decode(&amp;kv)</span><br><span class="line">kvSlice = <span class="built_in">append</span>(kvSlice,kv)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">file.Close()</span><br><span class="line"><span class="comment">/********/</span></span><br><span class="line"><span class="comment">//此处如果用 defer，可能会造成文件开启过多，造成程序崩溃</span></span><br><span class="line"><span class="comment">/********/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sort the intermediate kv slices by key</span></span><br><span class="line">sort.Sort(ByKey(kvSlice))</span><br><span class="line"></span><br><span class="line"><span class="comment">//process kv slices in the reduceF()</span></span><br><span class="line"><span class="keyword">var</span> reduceFValue []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> outputKv []KeyValue</span><br><span class="line"><span class="keyword">var</span> preKey <span class="keyword">string</span> = kvSlice[<span class="number">0</span>].Key</span><br><span class="line"><span class="keyword">for</span> i,kv := <span class="keyword">range</span> kvSlice&#123;</span><br><span class="line"><span class="keyword">if</span> i == (<span class="built_in">len</span>(kvSlice) - <span class="number">1</span>) &#123;</span><br><span class="line">reduceFValue = <span class="built_in">append</span>(reduceFValue, kv.Value)</span><br><span class="line">outputKv = <span class="built_in">append</span>(outputKv, KeyValue&#123;preKey, reduceF(preKey, reduceFValue)&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> kv.Key != preKey &#123;</span><br><span class="line">outputKv = <span class="built_in">append</span>(outputKv, KeyValue&#123;preKey, reduceF(preKey, reduceFValue)&#125;)</span><br><span class="line">reduceFValue = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">reduceFValue = <span class="built_in">append</span>(reduceFValue, kv.Value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">preKey = kv.Key</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//write the reduce output as JSON encoded kv objects to the file named outFile</span></span><br><span class="line">file,err := os.Create(outFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"doRuduce: create "</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">enc := json.NewEncoder(file)</span><br><span class="line"><span class="keyword">for</span> _, kv := <span class="keyword">range</span> outputKv&#123;</span><br><span class="line">err := enc.Encode(&amp;kv)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"doRuduce: json encode "</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Part-II-Single-worker-word-count"><a href="#Part-II-Single-worker-word-count" class="headerlink" title="Part II: Single-worker word count"></a>Part II: Single-worker word count</h2><p>第二部分是实现<code>mapF()</code> 和 <code>reduceF()</code>函数，来实现通过顺序 MR统计词频的功能。<br>比较简单，就直接放代码了。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF</span><span class="params">(filename <span class="keyword">string</span>, contents <span class="keyword">string</span>)</span> []<span class="title">mapreduce</span>.<span class="title">KeyValue</span></span> &#123;</span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> !unicode.IsLetter(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> strSlice []<span class="keyword">string</span> = strings.FieldsFunc(contents,f)</span><br><span class="line"><span class="keyword">var</span> kvSlice []mapreduce.KeyValue</span><br><span class="line"><span class="keyword">for</span> _,str := <span class="keyword">range</span> strSlice &#123;</span><br><span class="line">kvSlice = <span class="built_in">append</span>(kvSlice, mapreduce.KeyValue&#123;str, <span class="string">"1"</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> kvSlice</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduceF</span><span class="params">(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> cnt <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">for</span> _,str := <span class="keyword">range</span> values&#123;</span><br><span class="line">temp,err := strconv.ParseInt(str,<span class="number">10</span>,<span class="number">64</span>)</span><br><span class="line"><span class="keyword">if</span>(err != <span class="literal">nil</span>)&#123;</span><br><span class="line">fmt.Println(<span class="string">"wc :parseint "</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">cnt += temp</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> strconv.FormatInt(cnt,<span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Part-III-Distributing-MapReduce-tasks-amp-amp-Part-IV-Handling-worker-failures"><a href="#Part-III-Distributing-MapReduce-tasks-amp-amp-Part-IV-Handling-worker-failures" class="headerlink" title="Part III: Distributing MapReduce tasks &amp;&amp; Part IV: Handling worker failures"></a>Part III: Distributing MapReduce tasks &amp;&amp; Part IV: Handling worker failures</h2><p>第三部分和第四部分可以一起来做，主要是完成<code>schedule()</code>，实现一个通过线程并发执行 map worker 和 reduce worker 的 MR 框架。框架通过 RPC 来模拟分布式计算，并要带有 worker 的容灾功能。    </p><h3 id="TestBasic"><a href="#TestBasic" class="headerlink" title="TestBasic()"></a>TestBasic()</h3><p>测试函数启动两个线程运行<code>RUnWoker()</code>。  </p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestBasic</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">mr := setup()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> RunWorker(mr.address, port(<span class="string">"worker"</span>+strconv.Itoa(i)),</span><br><span class="line">MapFunc, ReduceFunc, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">mr.Wait()</span><br><span class="line">check(t, mr.files)</span><br><span class="line">checkWorker(t, mr.stats)</span><br><span class="line">cleanup(mr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### setup() &amp;&amp; Distributed()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>golang</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span> *<span class="title">Master</span></span> &#123;</span><br><span class="line">files := makeInputs(nMap)</span><br><span class="line">master := port(<span class="string">"master"</span>)</span><br><span class="line">mr := Distributed(<span class="string">"test"</span>, files, nReduce, master)</span><br><span class="line"><span class="keyword">return</span> mr</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">通过`</span>mr.startRPCServer()<span class="string">` 启动 master 的 RPC 服务器，然后通过 `</span>mr.run()<span class="string">`进行 worker 的调度。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>golang</span><br><span class="line"><span class="comment">// Distributed schedules map and reduce tasks on workers that register with the</span></span><br><span class="line"><span class="comment">// master over RPC.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Distributed</span><span class="params">(jobName <span class="keyword">string</span>, files []<span class="keyword">string</span>, nreduce <span class="keyword">int</span>, master <span class="keyword">string</span>)</span> <span class="params">(mr *Master)</span></span> &#123;</span><br><span class="line">mr = newMaster(master)</span><br><span class="line">mr.startRPCServer()</span><br><span class="line"><span class="keyword">go</span> mr.run(jobName, files, nreduce,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(phase jobPhase)</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> mr.forwardRegistrations(ch)</span><br><span class="line">schedule(mr.jobName, mr.files, mr.nReduce, phase, ch)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">mr.stats = mr.killWorkers()</span><br><span class="line">mr.stopRPCServer()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Master-forwardRegistrations"><a href="#Master-forwardRegistrations" class="headerlink" title="Master.forwardRegistrations()"></a>Master.forwardRegistrations()</h3><p>该函数通过worker 的数量来判断是否有新 worker 启动，一旦发现有新的 worker 启动，则使用管道（ch）通知<code>schedule()</code>。<br>理解该函数对实现后面的<code>schedule()</code>至关重要。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// helper function that sends information about all existing</span></span><br><span class="line"><span class="comment">// and newly registered workers to channel ch. schedule()</span></span><br><span class="line"><span class="comment">// reads ch to learn about workers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mr *Master)</span> <span class="title">forwardRegistrations</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">mr.Lock()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(mr.workers) &gt; i &#123;</span><br><span class="line"><span class="comment">// there's a worker that we haven't told schedule() about.</span></span><br><span class="line">w := mr.workers[i]</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- w &#125;() <span class="comment">// send without holding the lock.</span></span><br><span class="line">i = i + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// wait for Register() to add an entry to workers[]</span></span><br><span class="line"><span class="comment">// in response to an RPC from a new worker.</span></span><br><span class="line">mr.newCond.Wait()</span><br><span class="line">&#125;</span><br><span class="line">mr.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="schedule"><a href="#schedule" class="headerlink" title="schedule()"></a>schedule()</h3><p><code>shedule()</code>虽然不长，但实现起来还是有点难度的。<br><code>waitGroup</code>用来判断任务是否完成。<br><code>registerChan</code>来监听是否有新的 worker 启动，如果有的话，就启动一个线程来运行该 worker。通过新开线程来运行新 worker的逻辑比较符合分布式 MR 的特点。<br>对于 宕掉的worker执行<code>call()</code>操作时，会返回<code>false</code>。<br>每开始执行一个任务，就让<code>waitGroup</code>减一，而执行失败（<code>call()</code>返回 <code>false</code>）则将<code>waitGroup</code>加一，代表会将该任务安排给其他 worker。     </p><p><code>waitGroup.Wait()</code>则会等到任务完全执行完返回。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">(jobName <span class="keyword">string</span>, mapFiles []<span class="keyword">string</span>, nReduce <span class="keyword">int</span>, phase jobPhase, registerChan <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ntasks <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> n_other <span class="keyword">int</span> <span class="comment">// number of inputs (for reduce) or outputs (for map)</span></span><br><span class="line"><span class="keyword">switch</span> phase &#123;</span><br><span class="line"><span class="keyword">case</span> mapPhase:</span><br><span class="line">ntasks = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">n_other = nReduce</span><br><span class="line"><span class="keyword">case</span> reducePhase:</span><br><span class="line">ntasks = nReduce</span><br><span class="line">n_other = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Schedule: %v %v tasks (%d I/Os)\n"</span>, ntasks, phase, n_other)</span><br><span class="line"></span><br><span class="line"><span class="comment">// All ntasks tasks have to be scheduled on workers, and only once all of</span></span><br><span class="line"><span class="comment">// them have been completed successfully should the function return.</span></span><br><span class="line"><span class="comment">// Remember that workers may fail, and that any given worker may finish</span></span><br><span class="line"><span class="comment">// multiple tasks.</span></span><br><span class="line"></span><br><span class="line">waitGroup := sync.WaitGroup&#123;&#125;</span><br><span class="line">waitGroup.Add(ntasks)</span><br><span class="line"></span><br><span class="line">taskChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, ntasks)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;ntasks;i++  &#123;</span><br><span class="line">taskChan &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">ch := &lt;- registerChan</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">i := &lt;- taskChan</span><br><span class="line"><span class="keyword">if</span> call(c,<span class="string">"Worker.DoTask"</span>, &amp;DoTaskArgs&#123;jobName,</span><br><span class="line">mapFiles[i],phase,i,n_other&#125;,<span class="built_in">new</span>(<span class="keyword">struct</span>&#123;&#125;))&#123;</span><br><span class="line">waitGroup.Done()</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">taskChan &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(ch)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">waitGroup.Wait()</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Schedule: %v phase done\n"</span>, phase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="RunWorker"><a href="#RunWorker" class="headerlink" title="RunWorker()"></a>RunWorker()</h3><p>通过<code>RunWorker()</code> 来增加 worker。<br><code>nRPC</code>来控制 worker 的寿命，每接收一次 rpc 请求就 -1s。如果初始值为 -1，则代表改 worker 是永生的。</p><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RunWorker sets up a connection with the master, registers its address, and</span></span><br><span class="line"><span class="comment">// waits for tasks to be scheduled.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RunWorker</span><span class="params">(MasterAddress <span class="keyword">string</span>, me <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">MapFunc <span class="keyword">func</span>(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span>,</span></span><br><span class="line"><span class="function"><span class="title">ReduceFunc</span> <span class="title">func</span><span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>)</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function"><span class="title">nRPC</span> <span class="title">int</span>,</span></span><br><span class="line"><span class="function">)</span> &#123;</span><br><span class="line">debug(<span class="string">"RunWorker %s\n"</span>, me)</span><br><span class="line">wk := <span class="built_in">new</span>(Worker)</span><br><span class="line">wk.name = me</span><br><span class="line">wk.Map = MapFunc</span><br><span class="line">wk.Reduce = ReduceFunc</span><br><span class="line">wk.nRPC = nRPC</span><br><span class="line">rpcs := rpc.NewServer()</span><br><span class="line">rpcs.Register(wk)</span><br><span class="line">os.Remove(me) <span class="comment">// only needed for "unix"</span></span><br><span class="line">l, e := net.Listen(<span class="string">"unix"</span>, me)</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"RunWorker: worker "</span>, me, <span class="string">" error: "</span>, e)</span><br><span class="line">&#125;</span><br><span class="line">wk.l = l</span><br><span class="line">wk.register(MasterAddress)</span><br><span class="line"></span><br><span class="line"><span class="comment">// DON'T MODIFY CODE BELOW</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">wk.Lock()</span><br><span class="line"><span class="keyword">if</span> wk.nRPC == <span class="number">0</span> &#123;</span><br><span class="line">wk.Unlock()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">wk.Unlock()</span><br><span class="line">conn, err := wk.l.Accept()</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">wk.Lock()</span><br><span class="line">wk.nRPC--</span><br><span class="line">wk.Unlock()</span><br><span class="line"><span class="keyword">go</span> rpcs.ServeConn(conn)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">wk.l.Close()</span><br><span class="line">debug(<span class="string">"RunWorker %s exit\n"</span>, me)</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">## Part V: Inverted index generation</span></span><br><span class="line"><span class="string">第五部分是实现倒排索引。此处要求的倒排索引，就是在输出结果时，需要将出现过 key 值文件的文件名在 key 值后面输出。   </span></span><br><span class="line"><span class="string">功能是通过完成 `</span>mapF()<span class="string">` 和 `</span>reduceF()<span class="string">` 来实现的。  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### mapF()</span></span><br><span class="line"><span class="string">将key 值所在文件的文件名赋给 kv对 的value。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>golang</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF</span><span class="params">(document <span class="keyword">string</span>, value <span class="keyword">string</span>)</span> <span class="params">(res []mapreduce.KeyValue)</span></span> &#123;</span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> !unicode.IsLetter(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> strSlice []<span class="keyword">string</span> = strings.FieldsFunc(value,f)</span><br><span class="line"><span class="keyword">var</span> kvSlice []mapreduce.KeyValue</span><br><span class="line"><span class="keyword">for</span> _,str := <span class="keyword">range</span> strSlice &#123;</span><br><span class="line">kvSlice = <span class="built_in">append</span>(kvSlice, mapreduce.KeyValue&#123;str, document&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> kvSlice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="reduceF"><a href="#reduceF" class="headerlink" title="reduceF()"></a>reduceF()</h3><p>将相同 key 值的所有 value 打包并统计数量返回。</p><pre><code class="golang"><span class="function"><span class="keyword">func</span> <span class="title">reduceF</span><span class="params">(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">string</span></span> {    <span class="keyword">var</span> cnt <span class="keyword">int64</span>    <span class="keyword">var</span> documents <span class="keyword">string</span>    set := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)    <span class="keyword">for</span> _,str := <span class="keyword">range</span> values{        set[str] = <span class="literal">true</span>    }    <span class="keyword">var</span> keys []<span class="keyword">string</span>    <span class="keyword">for</span> key := <span class="keyword">range</span> set{        <span class="keyword">if</span> set[key] == <span class="literal">false</span>{            <span class="keyword">continue</span>        }        keys = <span class="built_in">append</span>(keys,key)    }    sort.Strings(keys)    <span class="keyword">for</span> _,key := <span class="keyword">range</span> keys{        cnt++        <span class="keyword">if</span> cnt &gt;= <span class="number">2</span>{            documents += <span class="string">","</span>        }        documents += key    }    <span class="comment">//return strconv.FormatInt(cnt,10)</span>    <span class="keyword">return</span> strconv.FormatInt(cnt,<span class="number">10</span>) + <span class="string">" "</span> + documents}</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>从刚开始的无从下手，到现在通过Lab1全部测试，MR 实验算是完全做完了，还是很有成就感的。<br>除了对 MR 有一个更深的理解之外，也深深感受到了优秀系统的魅力——功能强大，结构简洁。<br>同时又了解了一门新语言——GoLang，一门专门为高并发系统而设计的语言，用起来还是很舒服的。<br>但这毕竟是分布式系统的第一个实验，欠缺的知识还很多，继续努力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;MIT6.824 是我在学习一些分布式系统方面的知识的时候偶然看到的，然后就开始尝试跟课。不得不说，国外的课程难度是真的大，一周的时间居然要
      
    
    </summary>
    
      <category term="计算机" scheme="http://www.yufengli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="操作系统" scheme="http://www.yufengli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式系统" scheme="http://www.yufengli.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="MIT6.824" scheme="http://www.yufengli.cn/tags/MIT6-824/"/>
    
      <category term="MapReduce" scheme="http://www.yufengli.cn/tags/MapReduce/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.yufengli.cn/2018/06/06/hello-world/"/>
    <id>http://www.yufengli.cn/2018/06/06/hello-world/</id>
    <published>2018-06-06T06:02:25.000Z</published>
    <updated>2018-06-06T07:52:21.831Z</updated>
    
    <content type="html"><![CDATA[<p>这篇随笔就用来总结一下自己最近的生活，谈谈自己对未来的想法好了。作为博客的第一篇文章，名字就叫 Hello World 了。</p><h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><p>之前一直是在 CSDN 上写博客，CSDN 虽然使用简单方便，但是广告太多，界面也有些简陋，用起来不是很舒服。所以我就想着自己搭一个好了，还能记录一些非技术性的东西（主要是最近在养伤，算是比较闲，就想折腾一下）。其实之前是有一个基于 Github Pages 的博客的，但是上一个Github 账号删除的时候忘记保存，博客也就没了= =。</p><h2 id="专业方向"><a href="#专业方向" class="headerlink" title="专业方向"></a>专业方向</h2><p>从去年12月乌鲁木齐站结束到现在，ACM-ICPC 生活结束已经半年了。之前打 ACM-ICPC 的时候，不用想太多，就好好刷题，好好准备比赛和期末考试就好了。但 ACM-ICPC比赛总归是一道道的题，将来无论是工作还是深造，还是要落实到工程或者科研上的。所以这半年我也尝试不少新东西，寻找一下自己感兴趣的方向。很多人都说打 ACM-ICPC的算法好，退役后肯定是继续学像机器学习这样人工智能的东西，将来做一个高大上的算法工程师啊。确实，像人工智能算法做的好的话，价值还是很大的。但是我对纯算法的工作好像并不感兴趣，我更偏爱开发方面的工作，喜欢做偏计算机，而不是数学方向的工作。所以我未来理想的工作，是希望能够进入一个纯技术，像中间件， 云计算这样的团队进行底层系统的开发。<br>&lt;!–&gt;</p><h2 id="挂实习"><a href="#挂实习" class="headerlink" title="挂实习"></a>挂实习</h2><p>现在大三，面临着工作还是读研的问题。其实刚上大学的时候，是希望毕业就去工作的。那时候自信满满，觉得自己努力三年，绝对会在毕业斩获无数 offer。但是现实无情打脸，连实习都没找到= =（话说，ACM-ICPC银牌在找工作，尤其是开发方面的工作的时候，作用好像挺小的，估计主要还是我工程方面知识是在太差了，但银牌起码过 BAT 的简历应该没问题）。AT 两家跪掉之后，发现自己工程方面的知识不是一两天能突击回来的，就不想再找实习了，便专心保研了。  </p><h2 id="保研"><a href="#保研" class="headerlink" title="保研"></a>保研</h2><p>前一段时间对保研这件事耿耿于怀，总担心自己上不了好学校。但是在养伤期间（蓝桥杯归途出了些意外，头部缝了n针）心态也逐渐放平和了。我将来并不想走科研的道路，打算硕士毕业就工作了，所以学校的影响好像并不大。况且最差也是保本校，窝工虽然不上什么顶尖学校，但好歹也是双一流，应该不至于有学历歧视吧。所以不管去哪读书，只要方向合适，导师和善，我都能接受。</p><h2 id="尾语"><a href="#尾语" class="headerlink" title="尾语"></a>尾语</h2><blockquote><p>一个人的命运啊,既要考虑历史的进程,也要靠个人的奋斗!</p></blockquote><p>希望自己能保持对技术的热情，在这样一个互联网的时代中留下一些属于自己的痕迹吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇随笔就用来总结一下自己最近的生活，谈谈自己对未来的想法好了。作为博客的第一篇文章，名字就叫 Hello World 了。&lt;/p&gt;
&lt;h2 id=&quot;搭建博客&quot;&gt;&lt;a href=&quot;#搭建博客&quot; class=&quot;headerlink&quot; title=&quot;搭建博客&quot;&gt;&lt;/a&gt;搭建博客
      
    
    </summary>
    
      <category term="随笔" scheme="http://www.yufengli.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="生活" scheme="http://www.yufengli.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
