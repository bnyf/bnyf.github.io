<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Binary Lyf</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yufengli.cn/"/>
  <updated>2018-06-06T07:22:01.993Z</updated>
  <id>http://www.yufengli.cn/</id>
  
  <author>
    <name>bnyf</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSAPP Lab1-datalab</title>
    <link href="http://www.yufengli.cn/2018/06/06/csapp-lab1/"/>
    <id>http://www.yufengli.cn/2018/06/06/csapp-lab1/</id>
    <published>2018-06-06T06:27:35.000Z</published>
    <updated>2018-06-06T07:22:01.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CSAPP 这本书可以说是程序员必读专业书籍了。这本书以一个 “Hello World”  C语言程序为起点，通过跟踪整个”Hello World”程序的生命周期，来讲解系统为了执行该程序都做了哪些事情。就像书名一样，学习本书，能让我们对计算机系统有一个更深入的理解。<br>在学长的推荐下，我开始啃 CSAPP（《深入理解计算机系统》） 这本书，读了前两章，感觉难度还是不小的，但收获也是挺多的，尤其是 “计算机抽象等级” 和 “浮点数” 这两块知识，学了之后有种豁然开朗的感觉。  这本书还有一个特点就是配套的几个实验了，俗话说“纸上得来终觉浅”，配合着实验食用这本书，真是嘎嘣脆，事半功倍。<br>Lab1 对应的就是第二章的知识点，写起来挑战性还是很大的。</p><h2 id="Lab1-Solution"><a href="#Lab1-Solution" class="headerlink" title="Lab1 Solution"></a>Lab1 Solution</h2><p>Lab1 主要就是用 C 语言在一些操作限制的情况下实现题目要求。<br>主要的限制是操作符和操作数。还有一点要注意的就是变量的声明必须放在函数的最前面。<br>整个实验还是很有难度的，我们除了要对正数，浮点数二进制运算要非常熟悉外，还有很多 trick需要我们去思考，毕竟操作数是有限的，我们进行操作的时候要尽可能的“节约”。<br>每写完一道题都可以用 btest 测试一下，但是这个只能测试结果是否正确，操作是否合规无法测试。在所有题目都完成后，可以运行 Driver.pl 对程序进行一个完整的测试，如果能得到所有的分数，那么恭喜你，这个实验就算是圆满完成了。（当然如果想追求极致，可以尝试用更少的操作数来完成实验)</p><h3 id="bitAnd"><a href="#bitAnd" class="headerlink" title="bitAnd"></a>bitAnd</h3><p>x&amp;y = ~~(x&amp;y) = ~(~x|~y)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitAnd - x&amp;y using only ~ and | </span></span><br><span class="line"><span class="comment"> *   Example: bitAnd(6, 5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ |</span></span><br><span class="line"><span class="comment"> *   Max ops: 8</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitAnd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ~(~x | ~y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="getByte"><a href="#getByte" class="headerlink" title="getByte"></a>getByte</h3><p>将要取出的八位移动到最右端，并和 0xff 做且运算。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * getByte - Extract byte n from word x</span></span><br><span class="line"><span class="comment"> *   Bytes numbered from 0 (LSB) to 3 (MSB)</span></span><br><span class="line"><span class="comment"> *   Examples: getByte(0x12345678,1) = 0x56</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 6</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getByte</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x &gt;&gt; (n &lt;&lt; <span class="number">3</span>)) &amp; <span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="logicalShift"><a href="#logicalShift" class="headerlink" title="logicalShift"></a>logicalShift</h3><p>先进行算数右移，再将补充的高位置为0。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalShift - shift x to the right by n, using a logical shift</span></span><br><span class="line"><span class="comment"> *   Can assume that 0 &lt;= n &lt;= 31</span></span><br><span class="line"><span class="comment"> *   Examples: logicalShift(0x87654321,4) = 0x08765432</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 20</span></span><br><span class="line"><span class="comment"> *   Rating: 3 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalShift</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = (x &gt;&gt; n) &amp; (~(((<span class="number">1</span> &lt;&lt; <span class="number">31</span>) &gt;&gt; n) &lt;&lt; <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">```c</span><br><span class="line">### bitCount</span><br><span class="line">这道题是难度最大的一道了。   </span><br><span class="line">我们需要用二分的思想，先两位两位地统计<span class="number">1</span>的个数，并将答案存在这两位上。然后四位四位地统计，接着是八位，直到统计完三十二位。</span><br><span class="line">统计的时候运用错位相加的方法，需要注意的是在移位之前要将无关位置<span class="number">0</span>，以免无关位相加对结果造成影响。</span><br><span class="line">```c</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * bitCount - returns count of number of 1's in word</span></span><br><span class="line"><span class="comment"> *   Examples: bitCount(5) = 2, bitCount(7) = 3</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 40</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitCount</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0x55</span> | (<span class="number">0x55</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> mask1 = tmp | (tmp &lt;&lt; <span class="number">16</span>);</span><br><span class="line"><span class="keyword">int</span> tmp1 = <span class="number">0x33</span> | (<span class="number">0x33</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> mask2 = tmp1 | (tmp1 &lt;&lt; <span class="number">16</span>);</span><br><span class="line"><span class="keyword">int</span> tmp2 = <span class="number">0x0f</span> | (<span class="number">0x0f</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> mask3 = tmp2 | (tmp2 &lt;&lt; <span class="number">16</span>);</span><br><span class="line">x = (x &amp; mask1) + ((x &gt;&gt; <span class="number">1</span>) &amp; mask1);</span><br><span class="line">x = (x &amp; mask2) + ((x &gt;&gt; <span class="number">2</span>) &amp; mask2);</span><br><span class="line">    x = (x &amp; mask3) + ((x &gt;&gt; <span class="number">4</span>) &amp; mask3);</span><br><span class="line">x = x + (x &gt;&gt; <span class="number">8</span>);</span><br><span class="line">x = x + (x &gt;&gt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> x &amp; <span class="number">0x3f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="bang"><a href="#bang" class="headerlink" title="bang"></a>bang</h3><p>如果x是0的话，~0|0的符号位仍为0；x非0的话，~x|x 的符号位为1。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bang - Compute !x without using !</span></span><br><span class="line"><span class="comment"> *   Examples: bang(3) = 0, bang(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bang</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> minusx = ~x + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sign = (x | minusx) &gt;&gt; <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (~sign) &amp; <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h3><p>久违的送分题。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two's complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="fitsBits"><a href="#fitsBits" class="headerlink" title="fitsBits"></a>fitsBits</h3><p>这道题需要注意的就是符号位了。之所以向移动 (32-n) 位，而不是 (31-n)      位就是为了留出符号位。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * fitsBits - return 1 if x can be represented as an </span></span><br><span class="line"><span class="comment"> *  n-bit, two's complement integer.</span></span><br><span class="line"><span class="comment"> *   1 &lt;= n &lt;= 32</span></span><br><span class="line"><span class="comment"> *   Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fitsBits</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> shiftNumber = <span class="number">32</span> + (~n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> !((x &lt;&lt; shiftNumber &gt;&gt; shiftNumber) ^ x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="divpw2"><a href="#divpw2" class="headerlink" title="divpw2"></a>divpw2</h3><p>这题难点在于舍入。正数直接右移 n 位即可，负数则需要加一个偏移量再右移。<br>还有一点需要注意的就是掩码的求取了，需要一些技巧，毕竟操作数是有限的，还要节约使用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30</span></span><br><span class="line"><span class="comment"> *  Round toward zero</span></span><br><span class="line"><span class="comment"> *   Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divpwr2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> signx = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line"><span class="keyword">int</span> mask = (<span class="number">1</span> &lt;&lt; n) + (~<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> bias = signx &amp; mask;</span><br><span class="line"><span class="keyword">return</span> (x + bias) &gt;&gt; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h3><p>送分题。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="isPositive"><a href="#isPositive" class="headerlink" title="isPositive"></a>isPositive</h3><p>这道题难点在于0的判断。0有一个非常特殊的性质就是 !0 = 1，利用0的这个特点，此题就不难解出了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isPositive - return 1 if x &gt; 0, return 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Example: isPositive(-1) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 8</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPositive</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !((x &gt;&gt; <span class="number">31</span>) | (!x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h3><p>这道题相当于枚举 x&lt;=y 的所有情况：</p><ol><li>x为负数，y 为正数</li><li>x 等于 y</li><li>x 和 y 符号相同，并且 y-x 为正数<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> signx = (x&gt;&gt;<span class="number">31</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line"><span class="keyword">int</span> signy = (y&gt;&gt;<span class="number">31</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = signx ^ signy;</span><br><span class="line"><span class="keyword">int</span> tmp1 = tmp &amp; signx;</span><br><span class="line"><span class="keyword">int</span> y_minus_x = y+(~x+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> tmp1 | (!(x^y)) | (!tmp &amp; !(y_minus_x&amp;(<span class="number">1</span> &lt;&lt; <span class="number">31</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="ilgo2"><a href="#ilgo2" class="headerlink" title="ilgo2"></a>ilgo2</h3><p>求以2为底，x 的对数。<br>这道题算是难题之一了，其原理和 bitCount 有些类似，都是用二分的思想，但这道题是求出最高位的1。<br>通过二分整数的所有位，找出最高位1的位置。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ilog2 - return floor(log base 2 of x), where x &gt; 0</span></span><br><span class="line"><span class="comment"> *   Example: ilog2(16) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 90</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ilog2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> bitsNumber = <span class="number">0</span>;</span><br><span class="line">bitsNumber = (!!(x &gt;&gt; <span class="number">16</span>)) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">bitsNumber += (!!(x &gt;&gt; (bitsNumber + <span class="number">8</span>)) &lt;&lt; <span class="number">3</span>);</span><br><span class="line">bitsNumber += (!!(x &gt;&gt; (bitsNumber + <span class="number">4</span>)) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">bitsNumber += (!!(x &gt;&gt; (bitsNumber + <span class="number">2</span>)) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">bitsNumber += (!!(x &gt;&gt; (bitsNumber + <span class="number">1</span>)));</span><br><span class="line"><span class="keyword">return</span> bitsNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="float-neg"><a href="#float-neg" class="headerlink" title="float_neg"></a>float_neg</h3><p>从这道题开始就进入了浮点数的练习，这部分需要我们对 IEEE 浮点数编码先回顾一下。<br>这道题难点就在于 NaN 的判断，如果 uf 是 NaN，需要原值返回。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_neg - Return bit-level equivalent of expression -f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representations of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_neg</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> result = uf ^ (<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0xff</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line"><span class="keyword">if</span>((uf &amp; (tmp|(<span class="number">0xff</span> &lt;&lt; <span class="number">15</span>)|(<span class="number">0xff</span> &lt;&lt; <span class="number">7</span>)|<span class="number">0xff</span>)) &gt; tmp)&#123;</span><br><span class="line">result = uf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="float-i2f"><a href="#float-i2f" class="headerlink" title="float_i2f"></a>float_i2f</h3><p>这道题完全就是考察队 IEEE 浮点数编码的熟悉程度了。第一遍写的时候怎么都过不了，后来发现是望考虑舍入了。除此之外这道题操作数也是一个难点，需要用到不少小 trick 来精简操作数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_i2f - Return bit-level equivalent of expression (float) x</span></span><br><span class="line"><span class="comment"> *   Result is returned as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_i2f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> first1 = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">int</span> frac = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> tmp = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">int</span> <span class="built_in">exp</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mask = (<span class="number">0xff</span> &lt;&lt; <span class="number">15</span>)|(<span class="number">0xff</span> &lt;&lt; <span class="number">7</span>)|(<span class="number">0x7f</span>);</span><br><span class="line"><span class="keyword">int</span> mask1 = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line"><span class="keyword">int</span> sign = x &amp; mask1;</span><br><span class="line"><span class="keyword">if</span>(x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">x = -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(!(x &gt;&gt; first1))&#123;</span><br><span class="line">first1 = first1 - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(first1 &gt; <span class="number">23</span>)&#123;</span><br><span class="line">frac = (x &gt;&gt; (first1 - <span class="number">23</span>)) &amp; mask;</span><br><span class="line">tmp = x &lt;&lt; (<span class="number">55</span> - first1);</span><br><span class="line"><span class="keyword">if</span>(tmp &gt; mask1)</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tmp == mask1)&#123;</span><br><span class="line"><span class="keyword">if</span>(frac &amp; <span class="number">0x1</span>)</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">frac = (x &lt;&lt; (<span class="number">23</span> - first1)) &amp; mask;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exp</span> = <span class="number">127</span> + first1;</span><br><span class="line"><span class="keyword">return</span> sign + (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>) + frac + flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="float-twice"><a href="#float-twice" class="headerlink" title="float_twice"></a>float_twice</h3><p>最后一道题是浮点数二倍乘。无穷大和 NaN 就直接返回原值就好，规格化数阶码直接加1，非规格化数尾数左移一位（移位后可能变为规格化数，但这并不影响答案，这也正是 IEEE 浮点数编码的巧妙之处，不用担心)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_twice - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_twice</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mask1 = <span class="number">0xff</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line"><span class="keyword">unsigned</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>((uf &amp; mask1) == mask1)&#123;</span><br><span class="line">result = uf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>((uf &amp; mask1) == <span class="number">0x0</span>)&#123;</span><br><span class="line">result = (uf &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>)) | (uf &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">result = uf + (<span class="number">1</span> &lt;&lt; <span class="number">23</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>之前只知道浮点数有误差，但并不知其所以然。有些数，比如0.1是无法用浮点数准确表示的，只能近似表示。int转 float，long long 转 double 由于尾数限制，也都会被舍入。总的来说，浮点数的精度由尾数位数决定，范围是由阶码位数决定的。<br> CSAPP 这本书真的不错，无论是书上的知识还是实验的内容干货都非常的多。学了前两章，收获还是挺大的，尤其是整数和浮点数的二进制表示这部分知识。但是感觉进度实在是太慢了，按照现在的速度，今年都不一定把这本书看完= =，接下来还是提高效率，抓紧时间把这本书啃完吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;CSAPP 这本书可以说是程序员必读专业书籍了。这本书以一个 “Hello World”  C语言程序为起点，通过跟踪整个”Hello Wo
      
    
    </summary>
    
      <category term="计算机" scheme="http://www.yufengli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="操作系统" scheme="http://www.yufengli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://www.yufengli.cn/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.824 Lab1-MapReduce</title>
    <link href="http://www.yufengli.cn/2018/06/06/mit6-824-lab1/"/>
    <id>http://www.yufengli.cn/2018/06/06/mit6-824-lab1/</id>
    <published>2018-06-06T06:26:25.000Z</published>
    <updated>2018-06-06T07:25:58.279Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MIT6.824 是我在学习一些分布式系统方面的知识的时候偶然看到的，然后就开始尝试跟课。不得不说，国外的课程难度是真的大，一周的时间居然要学一门 Go 语言，然后还要读论文，进而做MapReduce 实验。<br>由于 MR（MapReduce） 框架需要建立在 DFS（Distributed File System）的基础上实现，所以本实验是通过使用<strong>多线程</strong>来模拟分布式环境。虽然难度上大大降低，但是通过该实验，还是会让我们对 MR 的核心原理有一个较为深刻的认识。<br>做实验之前我们需要先把经典的 MapReduce 论文给看了，窝比较建议直接看英文原文，但如果时间不充裕的话，可以直接在网上找中文的翻译版。<br>刚开始做这个实验的时候真的是一头雾水，完全不知道如何下手。后来发现这个工程有一个<strong>自动化测试文件（test_test.go）</strong>,每部分实验都会使用这个测试文件里的函数对代码进行测试。我们只要顺着这个测试函数逐步倒推，然后补全代码即可。       </p><h2 id="Part-I-Map-Reduce-input-and-output"><a href="#Part-I-Map-Reduce-input-and-output" class="headerlink" title="Part I: Map/Reduce input and output"></a>Part I: Map/Reduce input and output</h2><p>第一部分是先实现一个顺序版（sequential）的MR，让我们对 MR 的流程有一个大体的认识,并且实现<code>doMap()</code> 和 <code>doReduce()</code> 两个函数。<br>其包含两个测试函数<code>TestSequentialSingle()</code> 和 <code>TestSequentialMany()</code>。</p><h3 id="TestSequentialSingle"><a href="#TestSequentialSingle" class="headerlink" title="TestSequentialSingle()"></a>TestSequentialSingle()</h3><p>每个map worker处理一个文件，所以map worker的数量就等于文件的数量。<br>测试单个map worker 和 reduce worker。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSequentialSingle</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">mr := Sequential(<span class="string">"test"</span>, makeInputs(<span class="number">1</span>), <span class="number">1</span>, MapFunc, ReduceFunc)</span><br><span class="line">mr.Wait()</span><br><span class="line">check(t, mr.files)</span><br><span class="line">checkWorker(t, mr.stats)</span><br><span class="line">cleanup(mr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="TestSequentialMany（）"><a href="#TestSequentialMany（）" class="headerlink" title="TestSequentialMany（）"></a>TestSequentialMany（）</h3><p>此测试函数测试多个 map worker 和多个 reduce worker。<br>其运行逻辑和<code>TestSequentialSingle</code>类似。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSequentialMany</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">mr := Sequential(<span class="string">"test"</span>, makeInputs(<span class="number">5</span>), <span class="number">3</span>, MapFunc, ReduceFunc)</span><br><span class="line">mr.Wait()</span><br><span class="line">check(t, mr.files)</span><br><span class="line">checkWorker(t, mr.stats)</span><br><span class="line">cleanup(mr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Sequential"><a href="#Sequential" class="headerlink" title="Sequential()"></a>Sequential()</h3><p>测试函数将<code>工作名称，测试文件，reduce 的数量，用户定义的 map 函数，reduce 函数</code>五个实参传递给<code>Sequential()</code><br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sequential runs map and reduce tasks sequentially, waiting for each task to</span></span><br><span class="line"><span class="comment">// complete before running the next.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Sequential</span><span class="params">(jobName <span class="keyword">string</span>, files []<span class="keyword">string</span>, nreduce <span class="keyword">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">mapF <span class="keyword">func</span>(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span>,</span></span><br><span class="line"><span class="function"><span class="title">reduceF</span> <span class="title">func</span><span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>)</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function">) <span class="params">(mr *Master)</span></span> &#123;</span><br><span class="line">mr = newMaster(<span class="string">"master"</span>)</span><br><span class="line"><span class="keyword">go</span> mr.run(jobName, files, nreduce, <span class="function"><span class="keyword">func</span><span class="params">(phase jobPhase)</span></span> &#123;</span><br><span class="line"><span class="keyword">switch</span> phase &#123;</span><br><span class="line"><span class="keyword">case</span> mapPhase:</span><br><span class="line"><span class="keyword">for</span> i, f := <span class="keyword">range</span> mr.files &#123;</span><br><span class="line">doMap(mr.jobName, i, f, mr.nReduce, mapF)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> reducePhase:</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; mr.nReduce; i++ &#123;</span><br><span class="line">doReduce(mr.jobName, i, mergeName(mr.jobName, i), <span class="built_in">len</span>(mr.files), reduceF)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">mr.stats = []<span class="keyword">int</span>&#123;<span class="built_in">len</span>(files) + nreduce&#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="string">`Sequential()`</span>首先获取一个<span class="string">`Master`</span>对象的指针，然后利用函数闭包运行<span class="string">`Master.run()`</span>。</span><br></pre></td></tr></table></figure></p><h3 id="Master-run"><a href="#Master-run" class="headerlink" title="Master.run()"></a>Master.run()</h3><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// run executes a mapreduce job on the given number of mappers and reducers.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// First, it divides up the input file among the given number of mappers, and</span></span><br><span class="line"><span class="comment">// schedules each task on workers as they become available. Each map task bins</span></span><br><span class="line"><span class="comment">// its output in a number of bins equal to the given number of reduce tasks.</span></span><br><span class="line"><span class="comment">// Once all the mappers have finished, workers are assigned reduce tasks.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// When all tasks have been completed, the reducer outputs are merged,</span></span><br><span class="line"><span class="comment">// statistics are collected, and the master is shut down.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Note that this implementation assumes a shared file system.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mr *Master)</span> <span class="title">run</span><span class="params">(jobName <span class="keyword">string</span>, files []<span class="keyword">string</span>, nreduce <span class="keyword">int</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">schedule <span class="keyword">func</span>(phase jobPhase)</span>,</span></span><br><span class="line"><span class="function"><span class="title">finish</span> <span class="title">func</span><span class="params">()</span>,</span></span><br><span class="line"><span class="function">)</span> &#123;</span><br><span class="line">mr.jobName = jobName</span><br><span class="line">mr.files = files</span><br><span class="line">mr.nReduce = nreduce</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%s: Starting Map/Reduce task %s\n"</span>, mr.address, mr.jobName)</span><br><span class="line"></span><br><span class="line">schedule(mapPhase)</span><br><span class="line">schedule(reducePhase)</span><br><span class="line">finish()</span><br><span class="line">mr.merge()</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"%s: Map/Reduce task completed\n"</span>, mr.address)</span><br><span class="line"></span><br><span class="line">mr.doneChannel &lt;- <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="doMap"><a href="#doMap" class="headerlink" title="doMap()"></a>doMap()</h3><p><code>doMap()</code> 和 <code>doReduce()</code>是需要我们去实现的函数。<br><code>doMap()</code>的实现主要是将用户定义的<code>MapFunc()</code>切割的文本，通过 hash 分到 ‘nReduce’个切片中去。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doMap</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">jobName <span class="keyword">string</span>, // the name of the MapReduce job</span></span></span><br><span class="line"><span class="function"><span class="params">mapTaskNumber <span class="keyword">int</span>, // which <span class="keyword">map</span> task this is</span></span></span><br><span class="line"><span class="function"><span class="params">inFile <span class="keyword">string</span>,</span></span></span><br><span class="line">nReduce int, // the number of reduce task that will be run ("R" in the paper)</span><br><span class="line">mapF <span class="function"><span class="keyword">func</span><span class="params">(file <span class="keyword">string</span>, contents <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span>,</span></span><br><span class="line"><span class="function">)</span> &#123;</span><br><span class="line"><span class="comment">// read contents from 'infile'</span></span><br><span class="line">dat,err := ioutil.ReadFile(inFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"doMap: readFile "</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//transfer data into ‘kvSlice’ according to the mapF()</span></span><br><span class="line">kvSlice := mapF(inFile, <span class="keyword">string</span>(dat))</span><br><span class="line"></span><br><span class="line"><span class="comment">//divide the ‘kvSlice’ into 'reduceKv' according to the ihash()</span></span><br><span class="line"><span class="keyword">var</span> reduceKv [][]KeyValue <span class="comment">// temporary variable which will be written into reduce files</span></span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;nReduce;i++ &#123;</span><br><span class="line">s1 := <span class="built_in">make</span>([]KeyValue,<span class="number">0</span>)</span><br><span class="line">reduceKv = <span class="built_in">append</span>(reduceKv, s1)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> _,kv := <span class="keyword">range</span> kvSlice&#123;</span><br><span class="line">hash := ihash(kv.Key) % nReduce</span><br><span class="line">reduceKv[hash] = <span class="built_in">append</span>(reduceKv[hash],kv)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//write 'reduceKv' into ‘nReduce’ JSON files</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i&lt;nReduce;i++ &#123;</span><br><span class="line">file,err := os.Create(reduceName(jobName,mapTaskNumber,i))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"doMap: create "</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">enc := json.NewEncoder(file)</span><br><span class="line"><span class="keyword">for</span> _, kv := <span class="keyword">range</span> reduceKv[i]&#123;</span><br><span class="line">err := enc.Encode(&amp;kv)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"doMap: json encodem "</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">file.Close()</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">### doReduce()</span></span><br><span class="line"><span class="string">`</span>doReduce()<span class="string">`主要是将 key 值相同的 value 打包发送给用户定义的 `</span>ReduceFunc()<span class="string">`，获得一个新的 kv对，key 值不变，而value值则是`</span>ReduceFunc()<span class="string">`的返回值，排序，最后将新的 kv对 切片写入文件。</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>golang</span><br><span class="line"><span class="keyword">type</span> ByKey []KeyValue</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByKey)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span> &#123; <span class="keyword">return</span> <span class="built_in">len</span>(a) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByKey)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span> &#123; a[i],a[j] = a[j],a[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(a ByKey)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> a[i].Key &lt; a[j].Key &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">doReduce</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">jobName <span class="keyword">string</span>, // the name of the whole MapReduce job</span></span></span><br><span class="line"><span class="function"><span class="params">reduceTaskNumber <span class="keyword">int</span>, // which reduce task this is</span></span></span><br><span class="line"><span class="function"><span class="params">outFile <span class="keyword">string</span>, // write the output here</span></span></span><br><span class="line">nMap int, // the number of map tasks that were run ("M" in the paper)</span><br><span class="line">reduceF <span class="function"><span class="keyword">func</span><span class="params">(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function">)</span> &#123;</span><br><span class="line"><span class="comment">//read kv slice from the json file</span></span><br><span class="line"><span class="keyword">var</span> kvSlice []KeyValue</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>;i&lt;nMap;i++&#123;</span><br><span class="line"><span class="comment">//file, _ := os.OpenFile(reduceName(jobName,i,reduceTaskNumber), os.O_RDONLY, 0666)</span></span><br><span class="line">file,err := os.Open(reduceName(jobName,i,reduceTaskNumber))</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"doReduce: open "</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> kv KeyValue</span><br><span class="line">dec := json.NewDecoder(file)</span><br><span class="line"><span class="keyword">for</span>&#123;</span><br><span class="line">err := dec.Decode(&amp;kv)</span><br><span class="line">kvSlice = <span class="built_in">append</span>(kvSlice,kv)</span><br><span class="line"><span class="keyword">if</span> err == io.EOF &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">file.Close()</span><br><span class="line"><span class="comment">/********/</span></span><br><span class="line"><span class="comment">//此处如果用 defer，可能会造成文件开启过多，造成程序崩溃</span></span><br><span class="line"><span class="comment">/********/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//sort the intermediate kv slices by key</span></span><br><span class="line">sort.Sort(ByKey(kvSlice))</span><br><span class="line"></span><br><span class="line"><span class="comment">//process kv slices in the reduceF()</span></span><br><span class="line"><span class="keyword">var</span> reduceFValue []<span class="keyword">string</span></span><br><span class="line"><span class="keyword">var</span> outputKv []KeyValue</span><br><span class="line"><span class="keyword">var</span> preKey <span class="keyword">string</span> = kvSlice[<span class="number">0</span>].Key</span><br><span class="line"><span class="keyword">for</span> i,kv := <span class="keyword">range</span> kvSlice&#123;</span><br><span class="line"><span class="keyword">if</span> i == (<span class="built_in">len</span>(kvSlice) - <span class="number">1</span>) &#123;</span><br><span class="line">reduceFValue = <span class="built_in">append</span>(reduceFValue, kv.Value)</span><br><span class="line">outputKv = <span class="built_in">append</span>(outputKv, KeyValue&#123;preKey, reduceF(preKey, reduceFValue)&#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">if</span> kv.Key != preKey &#123;</span><br><span class="line">outputKv = <span class="built_in">append</span>(outputKv, KeyValue&#123;preKey, reduceF(preKey, reduceFValue)&#125;)</span><br><span class="line">reduceFValue = <span class="built_in">make</span>([]<span class="keyword">string</span>, <span class="number">0</span>)</span><br><span class="line">&#125;</span><br><span class="line">reduceFValue = <span class="built_in">append</span>(reduceFValue, kv.Value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">preKey = kv.Key</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//write the reduce output as JSON encoded kv objects to the file named outFile</span></span><br><span class="line">file,err := os.Create(outFile)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"doRuduce: create "</span>, err)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">defer</span> file.Close()</span><br><span class="line"></span><br><span class="line">enc := json.NewEncoder(file)</span><br><span class="line"><span class="keyword">for</span> _, kv := <span class="keyword">range</span> outputKv&#123;</span><br><span class="line">err := enc.Encode(&amp;kv)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"doRuduce: json encode "</span>, err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Part-II-Single-worker-word-count"><a href="#Part-II-Single-worker-word-count" class="headerlink" title="Part II: Single-worker word count"></a>Part II: Single-worker word count</h2><p>第二部分是实现<code>mapF()</code> 和 <code>reduceF()</code>函数，来实现通过顺序 MR统计词频的功能。<br>比较简单，就直接放代码了。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF</span><span class="params">(filename <span class="keyword">string</span>, contents <span class="keyword">string</span>)</span> []<span class="title">mapreduce</span>.<span class="title">KeyValue</span></span> &#123;</span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> !unicode.IsLetter(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> strSlice []<span class="keyword">string</span> = strings.FieldsFunc(contents,f)</span><br><span class="line"><span class="keyword">var</span> kvSlice []mapreduce.KeyValue</span><br><span class="line"><span class="keyword">for</span> _,str := <span class="keyword">range</span> strSlice &#123;</span><br><span class="line">kvSlice = <span class="built_in">append</span>(kvSlice, mapreduce.KeyValue&#123;str, <span class="string">"1"</span>&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> kvSlice</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reduceF</span><span class="params">(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">string</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> cnt <span class="keyword">int64</span></span><br><span class="line"><span class="keyword">for</span> _,str := <span class="keyword">range</span> values&#123;</span><br><span class="line">temp,err := strconv.ParseInt(str,<span class="number">10</span>,<span class="number">64</span>)</span><br><span class="line"><span class="keyword">if</span>(err != <span class="literal">nil</span>)&#123;</span><br><span class="line">fmt.Println(<span class="string">"wc :parseint "</span>,err)</span><br><span class="line">&#125;</span><br><span class="line">cnt += temp</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> strconv.FormatInt(cnt,<span class="number">10</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="Part-III-Distributing-MapReduce-tasks-amp-amp-Part-IV-Handling-worker-failures"><a href="#Part-III-Distributing-MapReduce-tasks-amp-amp-Part-IV-Handling-worker-failures" class="headerlink" title="Part III: Distributing MapReduce tasks &amp;&amp; Part IV: Handling worker failures"></a>Part III: Distributing MapReduce tasks &amp;&amp; Part IV: Handling worker failures</h2><p>第三部分和第四部分可以一起来做，主要是完成<code>schedule()</code>，实现一个通过线程并发执行 map worker 和 reduce worker 的 MR 框架。框架通过 RPC 来模拟分布式计算，并要带有 worker 的容灾功能。    </p><h3 id="TestBasic"><a href="#TestBasic" class="headerlink" title="TestBasic()"></a>TestBasic()</h3><p>测试函数启动两个线程运行<code>RUnWoker()</code>。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestBasic</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">mr := setup()</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">2</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> RunWorker(mr.address, port(<span class="string">"worker"</span>+strconv.Itoa(i)),</span><br><span class="line">MapFunc, ReduceFunc, <span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line">mr.Wait()</span><br><span class="line">check(t, mr.files)</span><br><span class="line">checkWorker(t, mr.stats)</span><br><span class="line">cleanup(mr)</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">### setup() &amp;&amp; Distributed()</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>golang</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">setup</span><span class="params">()</span> *<span class="title">Master</span></span> &#123;</span><br><span class="line">files := makeInputs(nMap)</span><br><span class="line">master := port(<span class="string">"master"</span>)</span><br><span class="line">mr := Distributed(<span class="string">"test"</span>, files, nReduce, master)</span><br><span class="line"><span class="keyword">return</span> mr</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">通过`</span>mr.startRPCServer()<span class="string">` 启动 master 的 RPC 服务器，然后通过 `</span>mr.run()<span class="string">`进行 worker 的调度。</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>golang</span><br><span class="line"><span class="comment">// Distributed schedules map and reduce tasks on workers that register with the</span></span><br><span class="line"><span class="comment">// master over RPC.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Distributed</span><span class="params">(jobName <span class="keyword">string</span>, files []<span class="keyword">string</span>, nreduce <span class="keyword">int</span>, master <span class="keyword">string</span>)</span> <span class="params">(mr *Master)</span></span> &#123;</span><br><span class="line">mr = newMaster(master)</span><br><span class="line">mr.startRPCServer()</span><br><span class="line"><span class="keyword">go</span> mr.run(jobName, files, nreduce,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">(phase jobPhase)</span></span> &#123;</span><br><span class="line">ch := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">string</span>)</span><br><span class="line"><span class="keyword">go</span> mr.forwardRegistrations(ch)</span><br><span class="line">schedule(mr.jobName, mr.files, mr.nReduce, phase, ch)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">mr.stats = mr.killWorkers()</span><br><span class="line">mr.stopRPCServer()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Master-forwardRegistrations"><a href="#Master-forwardRegistrations" class="headerlink" title="Master.forwardRegistrations()"></a>Master.forwardRegistrations()</h3><p>该函数通过worker 的数量来判断是否有新 worker 启动，一旦发现有新的 worker 启动，则使用管道（ch）通知<code>schedule()</code>。<br>理解该函数对实现后面的<code>schedule()</code>至关重要。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// helper function that sends information about all existing</span></span><br><span class="line"><span class="comment">// and newly registered workers to channel ch. schedule()</span></span><br><span class="line"><span class="comment">// reads ch to learn about workers.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(mr *Master)</span> <span class="title">forwardRegistrations</span><span class="params">(ch <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">i := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">mr.Lock()</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(mr.workers) &gt; i &#123;</span><br><span class="line"><span class="comment">// there's a worker that we haven't told schedule() about.</span></span><br><span class="line">w := mr.workers[i]</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123; ch &lt;- w &#125;() <span class="comment">// send without holding the lock.</span></span><br><span class="line">i = i + <span class="number">1</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">// wait for Register() to add an entry to workers[]</span></span><br><span class="line"><span class="comment">// in response to an RPC from a new worker.</span></span><br><span class="line">mr.newCond.Wait()</span><br><span class="line">&#125;</span><br><span class="line">mr.Unlock()</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="schedule"><a href="#schedule" class="headerlink" title="schedule()"></a>schedule()</h3><p><code>shedule()</code>虽然不长，但实现起来还是有点难度的。<br><code>waitGroup</code>用来判断任务是否完成。<br><code>registerChan</code>来监听是否有新的 worker 启动，如果有的话，就启动一个线程来运行该 worker。通过新开线程来运行新 worker的逻辑比较符合分布式 MR 的特点。<br>对于 宕掉的worker执行<code>call()</code>操作时，会返回<code>false</code>。<br>每开始执行一个任务，就让<code>waitGroup</code>减一，而执行失败（<code>call()</code>返回 <code>false</code>）则将<code>waitGroup</code>加一，代表会将该任务安排给其他 worker。     </p><p><code>waitGroup.Wait()</code>则会等到任务完全执行完返回。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">schedule</span><span class="params">(jobName <span class="keyword">string</span>, mapFiles []<span class="keyword">string</span>, nReduce <span class="keyword">int</span>, phase jobPhase, registerChan <span class="keyword">chan</span> <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">var</span> ntasks <span class="keyword">int</span></span><br><span class="line"><span class="keyword">var</span> n_other <span class="keyword">int</span> <span class="comment">// number of inputs (for reduce) or outputs (for map)</span></span><br><span class="line"><span class="keyword">switch</span> phase &#123;</span><br><span class="line"><span class="keyword">case</span> mapPhase:</span><br><span class="line">ntasks = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">n_other = nReduce</span><br><span class="line"><span class="keyword">case</span> reducePhase:</span><br><span class="line">ntasks = nReduce</span><br><span class="line">n_other = <span class="built_in">len</span>(mapFiles)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Schedule: %v %v tasks (%d I/Os)\n"</span>, ntasks, phase, n_other)</span><br><span class="line"></span><br><span class="line"><span class="comment">// All ntasks tasks have to be scheduled on workers, and only once all of</span></span><br><span class="line"><span class="comment">// them have been completed successfully should the function return.</span></span><br><span class="line"><span class="comment">// Remember that workers may fail, and that any given worker may finish</span></span><br><span class="line"><span class="comment">// multiple tasks.</span></span><br><span class="line"></span><br><span class="line">waitGroup := sync.WaitGroup&#123;&#125;</span><br><span class="line">waitGroup.Add(ntasks)</span><br><span class="line"></span><br><span class="line">taskChan := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">int</span>, ntasks)</span><br><span class="line"><span class="keyword">for</span> i:=<span class="number">0</span>;i&lt;ntasks;i++  &#123;</span><br><span class="line">taskChan &lt;- i</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">ch := &lt;- registerChan</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">i := &lt;- taskChan</span><br><span class="line"><span class="keyword">if</span> call(c,<span class="string">"Worker.DoTask"</span>, &amp;DoTaskArgs&#123;jobName,</span><br><span class="line">mapFiles[i],phase,i,n_other&#125;,<span class="built_in">new</span>(<span class="keyword">struct</span>&#123;&#125;))&#123;</span><br><span class="line">waitGroup.Done()</span><br><span class="line">&#125; <span class="keyword">else</span>&#123;</span><br><span class="line">taskChan &lt;- i</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(ch)</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">waitGroup.Wait()</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">"Schedule: %v phase done\n"</span>, phase)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="RunWorker"><a href="#RunWorker" class="headerlink" title="RunWorker()"></a>RunWorker()</h3><p>通过<code>RunWorker()</code> 来增加 worker。<br><code>nRPC</code>来控制 worker 的寿命，每接收一次 rpc 请求就 -1s。如果初始值为 -1，则代表改 worker 是永生的。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RunWorker sets up a connection with the master, registers its address, and</span></span><br><span class="line"><span class="comment">// waits for tasks to be scheduled.</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">RunWorker</span><span class="params">(MasterAddress <span class="keyword">string</span>, me <span class="keyword">string</span>,</span></span></span><br><span class="line"><span class="function"><span class="params">MapFunc <span class="keyword">func</span>(<span class="keyword">string</span>, <span class="keyword">string</span>)</span> []<span class="title">KeyValue</span>,</span></span><br><span class="line"><span class="function"><span class="title">ReduceFunc</span> <span class="title">func</span><span class="params">(<span class="keyword">string</span>, []<span class="keyword">string</span>)</span> <span class="title">string</span>,</span></span><br><span class="line"><span class="function"><span class="title">nRPC</span> <span class="title">int</span>,</span></span><br><span class="line"><span class="function">)</span> &#123;</span><br><span class="line">debug(<span class="string">"RunWorker %s\n"</span>, me)</span><br><span class="line">wk := <span class="built_in">new</span>(Worker)</span><br><span class="line">wk.name = me</span><br><span class="line">wk.Map = MapFunc</span><br><span class="line">wk.Reduce = ReduceFunc</span><br><span class="line">wk.nRPC = nRPC</span><br><span class="line">rpcs := rpc.NewServer()</span><br><span class="line">rpcs.Register(wk)</span><br><span class="line">os.Remove(me) <span class="comment">// only needed for "unix"</span></span><br><span class="line">l, e := net.Listen(<span class="string">"unix"</span>, me)</span><br><span class="line"><span class="keyword">if</span> e != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"RunWorker: worker "</span>, me, <span class="string">" error: "</span>, e)</span><br><span class="line">&#125;</span><br><span class="line">wk.l = l</span><br><span class="line">wk.register(MasterAddress)</span><br><span class="line"></span><br><span class="line"><span class="comment">// DON'T MODIFY CODE BELOW</span></span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">wk.Lock()</span><br><span class="line"><span class="keyword">if</span> wk.nRPC == <span class="number">0</span> &#123;</span><br><span class="line">wk.Unlock()</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">wk.Unlock()</span><br><span class="line">conn, err := wk.l.Accept()</span><br><span class="line"><span class="keyword">if</span> err == <span class="literal">nil</span> &#123;</span><br><span class="line">wk.Lock()</span><br><span class="line">wk.nRPC--</span><br><span class="line">wk.Unlock()</span><br><span class="line"><span class="keyword">go</span> rpcs.ServeConn(conn)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">wk.l.Close()</span><br><span class="line">debug(<span class="string">"RunWorker %s exit\n"</span>, me)</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`</span></span><br><span class="line"><span class="string">## Part V: Inverted index generation</span></span><br><span class="line"><span class="string">第五部分是实现倒排索引。此处要求的倒排索引，就是在输出结果时，需要将出现过 key 值文件的文件名在 key 值后面输出。   </span></span><br><span class="line"><span class="string">功能是通过完成 `</span>mapF()<span class="string">` 和 `</span>reduceF()<span class="string">` 来实现的。  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">### mapF()</span></span><br><span class="line"><span class="string">将key 值所在文件的文件名赋给 kv对 的value。</span></span><br><span class="line"><span class="string">`</span><span class="string">``</span>golang</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mapF</span><span class="params">(document <span class="keyword">string</span>, value <span class="keyword">string</span>)</span> <span class="params">(res []mapreduce.KeyValue)</span></span> &#123;</span><br><span class="line">f := <span class="function"><span class="keyword">func</span><span class="params">(c <span class="keyword">rune</span>)</span> <span class="title">bool</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> !unicode.IsLetter(c)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> strSlice []<span class="keyword">string</span> = strings.FieldsFunc(value,f)</span><br><span class="line"><span class="keyword">var</span> kvSlice []mapreduce.KeyValue</span><br><span class="line"><span class="keyword">for</span> _,str := <span class="keyword">range</span> strSlice &#123;</span><br><span class="line">kvSlice = <span class="built_in">append</span>(kvSlice, mapreduce.KeyValue&#123;str, document&#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> kvSlice</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="reduceF"><a href="#reduceF" class="headerlink" title="reduceF()"></a>reduceF()</h3><p>将相同 key 值的所有 value 打包并统计数量返回。</p><pre><code class="golang"><span class="function"><span class="keyword">func</span> <span class="title">reduceF</span><span class="params">(key <span class="keyword">string</span>, values []<span class="keyword">string</span>)</span> <span class="title">string</span></span> {    <span class="keyword">var</span> cnt <span class="keyword">int64</span>    <span class="keyword">var</span> documents <span class="keyword">string</span>    set := <span class="built_in">make</span>(<span class="keyword">map</span>[<span class="keyword">string</span>]<span class="keyword">bool</span>)    <span class="keyword">for</span> _,str := <span class="keyword">range</span> values{        set[str] = <span class="literal">true</span>    }    <span class="keyword">var</span> keys []<span class="keyword">string</span>    <span class="keyword">for</span> key := <span class="keyword">range</span> set{        <span class="keyword">if</span> set[key] == <span class="literal">false</span>{            <span class="keyword">continue</span>        }        keys = <span class="built_in">append</span>(keys,key)    }    sort.Strings(keys)    <span class="keyword">for</span> _,key := <span class="keyword">range</span> keys{        cnt++        <span class="keyword">if</span> cnt &gt;= <span class="number">2</span>{            documents += <span class="string">","</span>        }        documents += key    }    <span class="comment">//return strconv.FormatInt(cnt,10)</span>    <span class="keyword">return</span> strconv.FormatInt(cnt,<span class="number">10</span>) + <span class="string">" "</span> + documents}</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>从刚开始的无从下手，到现在通过Lab1全部测试，MR 实验算是完全做完了，还是很有成就感的。<br>除了对 MR 有一个更深的理解之外，也深深感受到了优秀系统的魅力——功能强大，结构简洁。<br>同时又了解了一门新语言——GoLang，一门专门为高并发系统而设计的语言，用起来还是很舒服的。<br>但这毕竟是分布式系统的第一个实验，欠缺的知识还很多，继续努力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;MIT6.824 是我在学习一些分布式系统方面的知识的时候偶然看到的，然后就开始尝试跟课。不得不说，国外的课程难度是真的大，一周的时间居然要
      
    
    </summary>
    
      <category term="计算机" scheme="http://www.yufengli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="操作系统" scheme="http://www.yufengli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式系统" scheme="http://www.yufengli.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="MIT6.824" scheme="http://www.yufengli.cn/tags/MIT6-824/"/>
    
      <category term="MapReduce" scheme="http://www.yufengli.cn/tags/MapReduce/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.yufengli.cn/2018/06/06/hello-world/"/>
    <id>http://www.yufengli.cn/2018/06/06/hello-world/</id>
    <published>2018-06-06T06:02:25.000Z</published>
    <updated>2018-06-06T07:03:25.218Z</updated>
    
    <content type="html"><![CDATA[<p>这篇随笔就用来总结一下自己最近的生活，谈谈自己对未来的想法好了。作为博客的第一篇文章，名字就叫 Hello World 了。</p><h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><p>之前一直是在 CSDN 上写博客，CSDN 虽然使用简单方便，但是广告太多，界面也有些简陋，用起来不是很舒服。所以我就想着自己搭一个好了，还能记录一些非技术性的东西（主要是最近在养伤，算是比较闲，就想折腾一下）。其实之前是有一个基于 Github Page 的博客的，但是上一个Github 账号删除的时候忘记保存，博客也就没了= =。</p><h2 id="专业方向"><a href="#专业方向" class="headerlink" title="专业方向"></a>专业方向</h2><p>从去年12月乌鲁木齐站结束到现在，ACM-ICPC 生活结束已经半年了。之前打 ACM-ICPC 的时候，不用想太多，就好好刷题，好好准备比赛和期末考试就好了。但 ACM-ICPC比赛总归是一道道的题，将来无论是工作还是深造，还是要落实到工程或者科研上的。所以这半年我也尝试不少新东西，寻找一下自己感兴趣的方向。很多人都说打 ACM-ICPC的算法好，退役后肯定是继续学像机器学习这样人工智能的东西，将来做一个高大上的算法工程师啊。确实，像人工智能算法做的好的话，价值还是很大的。但是我对纯算法的工作好像并不感兴趣，我更偏爱开发方面的工作，喜欢做偏计算机，而不是数学方向的工作。所以我未来理想的工作，是希望能够进入一个纯技术，像中间件， 云计算这样的团队进行底层系统的开发。<br>&lt;!–&gt;</p><h2 id="挂实习"><a href="#挂实习" class="headerlink" title="挂实习"></a>挂实习</h2><p>现在大三，面临着工作还是读研的问题。其实刚上大学的时候，是希望毕业就去工作的。那时候自信满满，觉得自己努力三年，绝对会在毕业斩获无数 offer。但是现实无情打脸，连实习都没找到= =（话说，ACM-ICPC银牌在找工作，尤其是开发方面的工作的时候，作用好像挺小的，估计主要还是我工程方面知识是在太差了，但银牌起码过 BAT 的简历应该没问题）。AT 两家跪掉之后，发现自己工程方面的知识不是一两天能突击回来的，就不想再找实习了，便专心保研了。  </p><h2 id="保研"><a href="#保研" class="headerlink" title="保研"></a>保研</h2><p>前一段时间对保研这件事耿耿于怀，总担心自己上不了好学校。但是在养伤期间（蓝桥杯归途出了些意外，头部缝了n针）心态也逐渐放平和了。我将来并不想走科研的道路，打算硕士毕业就工作了，所以学校的影响好像并不大。况且最差也是保本校，窝工虽然不上什么顶尖学校，但好歹也是双一流，应该不至于有学历歧视吧。所以不管去哪读书，只要方向合适，导师和善，我都能接受。</p><h2 id="尾语"><a href="#尾语" class="headerlink" title="尾语"></a>尾语</h2><blockquote><p>一个人的命运啊,既要考虑历史的进程,也要靠个人的奋斗!</p></blockquote><p>希望自己能保持对技术的热情，在这样一个互联网的时代中留下一些属于自己的痕迹吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇随笔就用来总结一下自己最近的生活，谈谈自己对未来的想法好了。作为博客的第一篇文章，名字就叫 Hello World 了。&lt;/p&gt;
&lt;h2 id=&quot;搭建博客&quot;&gt;&lt;a href=&quot;#搭建博客&quot; class=&quot;headerlink&quot; title=&quot;搭建博客&quot;&gt;&lt;/a&gt;搭建博客
      
    
    </summary>
    
      <category term="随笔" scheme="http://www.yufengli.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="生活" scheme="http://www.yufengli.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
