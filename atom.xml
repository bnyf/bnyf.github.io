<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Binary Lyf</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.yufengli.cn/"/>
  <updated>2018-06-06T07:22:01.993Z</updated>
  <id>http://www.yufengli.cn/</id>
  
  <author>
    <name>bnyf</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSAPP Lab1-datalab</title>
    <link href="http://www.yufengli.cn/2018/06/06/csapp-lab1/"/>
    <id>http://www.yufengli.cn/2018/06/06/csapp-lab1/</id>
    <published>2018-06-06T06:27:35.000Z</published>
    <updated>2018-06-06T07:22:01.993Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>CSAPP 这本书可以说是程序员必读专业书籍了。这本书以一个 “Hello World”  C语言程序为起点，通过跟踪整个”Hello World”程序的生命周期，来讲解系统为了执行该程序都做了哪些事情。就像书名一样，学习本书，能让我们对计算机系统有一个更深入的理解。<br>在学长的推荐下，我开始啃 CSAPP（《深入理解计算机系统》） 这本书，读了前两章，感觉难度还是不小的，但收获也是挺多的，尤其是 “计算机抽象等级” 和 “浮点数” 这两块知识，学了之后有种豁然开朗的感觉。  这本书还有一个特点就是配套的几个实验了，俗话说“纸上得来终觉浅”，配合着实验食用这本书，真是嘎嘣脆，事半功倍。<br>Lab1 对应的就是第二章的知识点，写起来挑战性还是很大的。</p><h2 id="Lab1-Solution"><a href="#Lab1-Solution" class="headerlink" title="Lab1 Solution"></a>Lab1 Solution</h2><p>Lab1 主要就是用 C 语言在一些操作限制的情况下实现题目要求。<br>主要的限制是操作符和操作数。还有一点要注意的就是变量的声明必须放在函数的最前面。<br>整个实验还是很有难度的，我们除了要对正数，浮点数二进制运算要非常熟悉外，还有很多 trick需要我们去思考，毕竟操作数是有限的，我们进行操作的时候要尽可能的“节约”。<br>每写完一道题都可以用 btest 测试一下，但是这个只能测试结果是否正确，操作是否合规无法测试。在所有题目都完成后，可以运行 Driver.pl 对程序进行一个完整的测试，如果能得到所有的分数，那么恭喜你，这个实验就算是圆满完成了。（当然如果想追求极致，可以尝试用更少的操作数来完成实验)</p><h3 id="bitAnd"><a href="#bitAnd" class="headerlink" title="bitAnd"></a>bitAnd</h3><p>x&amp;y = ~~(x&amp;y) = ~(~x|~y)<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bitAnd - x&amp;y using only ~ and | </span></span><br><span class="line"><span class="comment"> *   Example: bitAnd(6, 5) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ |</span></span><br><span class="line"><span class="comment"> *   Max ops: 8</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitAnd</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ~(~x | ~y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="getByte"><a href="#getByte" class="headerlink" title="getByte"></a>getByte</h3><p>将要取出的八位移动到最右端，并和 0xff 做且运算。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * getByte - Extract byte n from word x</span></span><br><span class="line"><span class="comment"> *   Bytes numbered from 0 (LSB) to 3 (MSB)</span></span><br><span class="line"><span class="comment"> *   Examples: getByte(0x12345678,1) = 0x56</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 6</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getByte</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> (x &gt;&gt; (n &lt;&lt; <span class="number">3</span>)) &amp; <span class="number">0xff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="logicalShift"><a href="#logicalShift" class="headerlink" title="logicalShift"></a>logicalShift</h3><p>先进行算数右移，再将补充的高位置为0。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * logicalShift - shift x to the right by n, using a logical shift</span></span><br><span class="line"><span class="comment"> *   Can assume that 0 &lt;= n &lt;= 31</span></span><br><span class="line"><span class="comment"> *   Examples: logicalShift(0x87654321,4) = 0x08765432</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 20</span></span><br><span class="line"><span class="comment"> *   Rating: 3 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">logicalShift</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> result = (x &gt;&gt; n) &amp; (~(((<span class="number">1</span> &lt;&lt; <span class="number">31</span>) &gt;&gt; n) &lt;&lt; <span class="number">1</span>));</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line">```c</span><br><span class="line">### bitCount</span><br><span class="line">这道题是难度最大的一道了。   </span><br><span class="line">我们需要用二分的思想，先两位两位地统计<span class="number">1</span>的个数，并将答案存在这两位上。然后四位四位地统计，接着是八位，直到统计完三十二位。</span><br><span class="line">统计的时候运用错位相加的方法，需要注意的是在移位之前要将无关位置<span class="number">0</span>，以免无关位相加对结果造成影响。</span><br><span class="line">```c</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * bitCount - returns count of number of 1's in word</span></span><br><span class="line"><span class="comment"> *   Examples: bitCount(5) = 2, bitCount(7) = 3</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 40</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bitCount</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0x55</span> | (<span class="number">0x55</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> mask1 = tmp | (tmp &lt;&lt; <span class="number">16</span>);</span><br><span class="line"><span class="keyword">int</span> tmp1 = <span class="number">0x33</span> | (<span class="number">0x33</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> mask2 = tmp1 | (tmp1 &lt;&lt; <span class="number">16</span>);</span><br><span class="line"><span class="keyword">int</span> tmp2 = <span class="number">0x0f</span> | (<span class="number">0x0f</span> &lt;&lt; <span class="number">8</span>);</span><br><span class="line"><span class="keyword">int</span> mask3 = tmp2 | (tmp2 &lt;&lt; <span class="number">16</span>);</span><br><span class="line">x = (x &amp; mask1) + ((x &gt;&gt; <span class="number">1</span>) &amp; mask1);</span><br><span class="line">x = (x &amp; mask2) + ((x &gt;&gt; <span class="number">2</span>) &amp; mask2);</span><br><span class="line">    x = (x &amp; mask3) + ((x &gt;&gt; <span class="number">4</span>) &amp; mask3);</span><br><span class="line">x = x + (x &gt;&gt; <span class="number">8</span>);</span><br><span class="line">x = x + (x &gt;&gt; <span class="number">16</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> x &amp; <span class="number">0x3f</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="bang"><a href="#bang" class="headerlink" title="bang"></a>bang</h3><p>如果x是0的话，~0|0的符号位仍为0；x非0的话，~x|x 的符号位为1。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * bang - Compute !x without using !</span></span><br><span class="line"><span class="comment"> *   Examples: bang(3) = 0, bang(0) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 12</span></span><br><span class="line"><span class="comment"> *   Rating: 4 </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bang</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> minusx = ~x + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> sign = (x | minusx) &gt;&gt; <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> (~sign) &amp; <span class="number">0x1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="tmin"><a href="#tmin" class="headerlink" title="tmin"></a>tmin</h3><p>久违的送分题。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * tmin - return minimum two's complement integer </span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 4</span></span><br><span class="line"><span class="comment"> *   Rating: 1</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tmin</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="fitsBits"><a href="#fitsBits" class="headerlink" title="fitsBits"></a>fitsBits</h3><p>这道题需要注意的就是符号位了。之所以向移动 (32-n) 位，而不是 (31-n)      位就是为了留出符号位。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * fitsBits - return 1 if x can be represented as an </span></span><br><span class="line"><span class="comment"> *  n-bit, two's complement integer.</span></span><br><span class="line"><span class="comment"> *   1 &lt;= n &lt;= 32</span></span><br><span class="line"><span class="comment"> *   Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fitsBits</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> shiftNumber = <span class="number">32</span> + (~n + <span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> !((x &lt;&lt; shiftNumber &gt;&gt; shiftNumber) ^ x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="divpw2"><a href="#divpw2" class="headerlink" title="divpw2"></a>divpw2</h3><p>这题难点在于舍入。正数直接右移 n 位即可，负数则需要加一个偏移量再右移。<br>还有一点需要注意的就是掩码的求取了，需要一些技巧，毕竟操作数是有限的，还要节约使用。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30</span></span><br><span class="line"><span class="comment"> *  Round toward zero</span></span><br><span class="line"><span class="comment"> *   Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 15</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">divpwr2</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> signx = x &gt;&gt; <span class="number">31</span>;</span><br><span class="line"><span class="keyword">int</span> mask = (<span class="number">1</span> &lt;&lt; n) + (~<span class="number">0</span>);</span><br><span class="line"><span class="keyword">int</span> bias = signx &amp; mask;</span><br><span class="line"><span class="keyword">return</span> (x + bias) &gt;&gt; n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="negate"><a href="#negate" class="headerlink" title="negate"></a>negate</h3><p>送分题。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * negate - return -x </span></span><br><span class="line"><span class="comment"> *   Example: negate(1) = -1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 5</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">negate</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> ~x + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="isPositive"><a href="#isPositive" class="headerlink" title="isPositive"></a>isPositive</h3><p>这道题难点在于0的判断。0有一个非常特殊的性质就是 !0 = 1，利用0的这个特点，此题就不难解出了。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isPositive - return 1 if x &gt; 0, return 0 otherwise </span></span><br><span class="line"><span class="comment"> *   Example: isPositive(-1) = 0.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 8</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isPositive</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> !((x &gt;&gt; <span class="number">31</span>) | (!x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="isLessOrEqual"><a href="#isLessOrEqual" class="headerlink" title="isLessOrEqual"></a>isLessOrEqual</h3><p>这道题相当于枚举 x&lt;=y 的所有情况：</p><ol><li>x为负数，y 为正数</li><li>x 等于 y</li><li>x 和 y 符号相同，并且 y-x 为正数<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * isLessOrEqual - if x &lt;= y  then return 1, else return 0 </span></span><br><span class="line"><span class="comment"> *   Example: isLessOrEqual(4,5) = 1.</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 24</span></span><br><span class="line"><span class="comment"> *   Rating: 3</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isLessOrEqual</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> signx = (x&gt;&gt;<span class="number">31</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line"><span class="keyword">int</span> signy = (y&gt;&gt;<span class="number">31</span>) &amp; <span class="number">0x1</span>;</span><br><span class="line"><span class="keyword">int</span> tmp = signx ^ signy;</span><br><span class="line"><span class="keyword">int</span> tmp1 = tmp &amp; signx;</span><br><span class="line"><span class="keyword">int</span> y_minus_x = y+(~x+<span class="number">1</span>);</span><br><span class="line"><span class="keyword">return</span> tmp1 | (!(x^y)) | (!tmp &amp; !(y_minus_x&amp;(<span class="number">1</span> &lt;&lt; <span class="number">31</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="ilgo2"><a href="#ilgo2" class="headerlink" title="ilgo2"></a>ilgo2</h3><p>求以2为底，x 的对数。<br>这道题算是难题之一了，其原理和 bitCount 有些类似，都是用二分的思想，但这道题是求出最高位的1。<br>通过二分整数的所有位，找出最高位1的位置。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * ilog2 - return floor(log base 2 of x), where x &gt; 0</span></span><br><span class="line"><span class="comment"> *   Example: ilog2(16) = 4</span></span><br><span class="line"><span class="comment"> *   Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt;</span></span><br><span class="line"><span class="comment"> *   Max ops: 90</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ilog2</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> bitsNumber = <span class="number">0</span>;</span><br><span class="line">bitsNumber = (!!(x &gt;&gt; <span class="number">16</span>)) &lt;&lt; <span class="number">4</span>;</span><br><span class="line">bitsNumber += (!!(x &gt;&gt; (bitsNumber + <span class="number">8</span>)) &lt;&lt; <span class="number">3</span>);</span><br><span class="line">bitsNumber += (!!(x &gt;&gt; (bitsNumber + <span class="number">4</span>)) &lt;&lt; <span class="number">2</span>);</span><br><span class="line">bitsNumber += (!!(x &gt;&gt; (bitsNumber + <span class="number">2</span>)) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">bitsNumber += (!!(x &gt;&gt; (bitsNumber + <span class="number">1</span>)));</span><br><span class="line"><span class="keyword">return</span> bitsNumber;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="float-neg"><a href="#float-neg" class="headerlink" title="float_neg"></a>float_neg</h3><p>从这道题开始就进入了浮点数的练习，这部分需要我们对 IEEE 浮点数编码先回顾一下。<br>这道题难点就在于 NaN 的判断，如果 uf 是 NaN，需要原值返回。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_neg - Return bit-level equivalent of expression -f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representations of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 10</span></span><br><span class="line"><span class="comment"> *   Rating: 2</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_neg</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> result = uf ^ (<span class="number">1</span> &lt;&lt; <span class="number">31</span>);</span><br><span class="line"><span class="keyword">int</span> tmp = <span class="number">0xff</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line"><span class="keyword">if</span>((uf &amp; (tmp|(<span class="number">0xff</span> &lt;&lt; <span class="number">15</span>)|(<span class="number">0xff</span> &lt;&lt; <span class="number">7</span>)|<span class="number">0xff</span>)) &gt; tmp)&#123;</span><br><span class="line">result = uf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="float-i2f"><a href="#float-i2f" class="headerlink" title="float_i2f"></a>float_i2f</h3><p>这道题完全就是考察队 IEEE 浮点数编码的熟悉程度了。第一遍写的时候怎么都过不了，后来发现是望考虑舍入了。除此之外这道题操作数也是一个难点，需要用到不少小 trick 来精简操作数。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_i2f - Return bit-level equivalent of expression (float) x</span></span><br><span class="line"><span class="comment"> *   Result is returned as unsigned int, but</span></span><br><span class="line"><span class="comment"> *   it is to be interpreted as the bit-level representation of a</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_i2f</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> first1 = <span class="number">31</span>;</span><br><span class="line"><span class="keyword">int</span> frac = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> flag = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> tmp = <span class="number">0</span>;  </span><br><span class="line"><span class="keyword">int</span> <span class="built_in">exp</span> = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> mask = (<span class="number">0xff</span> &lt;&lt; <span class="number">15</span>)|(<span class="number">0xff</span> &lt;&lt; <span class="number">7</span>)|(<span class="number">0x7f</span>);</span><br><span class="line"><span class="keyword">int</span> mask1 = <span class="number">1</span> &lt;&lt; <span class="number">31</span>;</span><br><span class="line"><span class="keyword">int</span> sign = x &amp; mask1;</span><br><span class="line"><span class="keyword">if</span>(x &lt; <span class="number">0</span>)&#123;</span><br><span class="line">x = -x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(x == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(x &gt; <span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">while</span>(!(x &gt;&gt; first1))&#123;</span><br><span class="line">first1 = first1 - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(first1 &gt; <span class="number">23</span>)&#123;</span><br><span class="line">frac = (x &gt;&gt; (first1 - <span class="number">23</span>)) &amp; mask;</span><br><span class="line">tmp = x &lt;&lt; (<span class="number">55</span> - first1);</span><br><span class="line"><span class="keyword">if</span>(tmp &gt; mask1)</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(tmp == mask1)&#123;</span><br><span class="line"><span class="keyword">if</span>(frac &amp; <span class="number">0x1</span>)</span><br><span class="line">flag = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">frac = (x &lt;&lt; (<span class="number">23</span> - first1)) &amp; mask;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">exp</span> = <span class="number">127</span> + first1;</span><br><span class="line"><span class="keyword">return</span> sign + (<span class="built_in">exp</span> &lt;&lt; <span class="number">23</span>) + frac + flag;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="float-twice"><a href="#float-twice" class="headerlink" title="float_twice"></a>float_twice</h3><p>最后一道题是浮点数二倍乘。无穷大和 NaN 就直接返回原值就好，规格化数阶码直接加1，非规格化数尾数左移一位（移位后可能变为规格化数，但这并不影响答案，这也正是 IEEE 浮点数编码的巧妙之处，不用担心)。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment"> * float_twice - Return bit-level equivalent of expression 2*f for</span></span><br><span class="line"><span class="comment"> *   floating point argument f.</span></span><br><span class="line"><span class="comment"> *   Both the argument and result are passed as unsigned int's, but</span></span><br><span class="line"><span class="comment"> *   they are to be interpreted as the bit-level representation of</span></span><br><span class="line"><span class="comment"> *   single-precision floating point values.</span></span><br><span class="line"><span class="comment"> *   When argument is NaN, return argument</span></span><br><span class="line"><span class="comment"> *   Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while</span></span><br><span class="line"><span class="comment"> *   Max ops: 30</span></span><br><span class="line"><span class="comment"> *   Rating: 4</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="title">float_twice</span><span class="params">(<span class="keyword">unsigned</span> uf)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> mask1 = <span class="number">0xff</span> &lt;&lt; <span class="number">23</span>;</span><br><span class="line"><span class="keyword">unsigned</span> result = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>((uf &amp; mask1) == mask1)&#123;</span><br><span class="line">result = uf;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>((uf &amp; mask1) == <span class="number">0x0</span>)&#123;</span><br><span class="line">result = (uf &amp; (<span class="number">1</span> &lt;&lt; <span class="number">31</span>)) | (uf &lt;&lt; <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">result = uf + (<span class="number">1</span> &lt;&lt; <span class="number">23</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>之前只知道浮点数有误差，但并不知其所以然。有些数，比如0.1是无法用浮点数准确表示的，只能近似表示。int转 float，long long 转 double 由于尾数限制，也都会被舍入。总的来说，浮点数的精度由尾数位数决定，范围是由阶码位数决定的。<br> CSAPP 这本书真的不错，无论是书上的知识还是实验的内容干货都非常的多。学了前两章，收获还是挺大的，尤其是整数和浮点数的二进制表示这部分知识。但是感觉进度实在是太慢了，按照现在的速度，今年都不一定把这本书看完= =，接下来还是提高效率，抓紧时间把这本书啃完吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;CSAPP 这本书可以说是程序员必读专业书籍了。这本书以一个 “Hello World”  C语言程序为起点，通过跟踪整个”Hello Wo
      
    
    </summary>
    
      <category term="计算机" scheme="http://www.yufengli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="操作系统" scheme="http://www.yufengli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="深入理解计算机系统" scheme="http://www.yufengli.cn/tags/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>MIT6.824 Lab1-MapReduce</title>
    <link href="http://www.yufengli.cn/2018/06/06/mit6-824-lab1/"/>
    <id>http://www.yufengli.cn/2018/06/06/mit6-824-lab1/</id>
    <published>2018-06-06T06:26:25.000Z</published>
    <updated>2018-06-06T07:22:38.823Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>MIT6.824 是我在学习一些分布式系统方面的知识的时候偶然看到的，然后就开始尝试跟课。不得不说，国外的课程难度是真的大，一周的时间居然要学一门 Go 语言，然后还要读论文，进而做MapReduce 实验。<br>由于 MR（MapReduce） 框架需要建立在 DFS（Distributed File System）的基础上实现，所以本实验是通过使用<strong>多线程</strong>来模拟分布式环境。虽然难度上大大降低，但是通过该实验，还是会让我们对 MR 的核心原理有一个较为深刻的认识。<br>做实验之前我们需要先把经典的 MapReduce 论文给看了，窝比较建议直接看英文原文，但如果时间不充裕的话，可以直接在网上找中文的翻译版。<br>刚开始做这个实验的时候真的是一头雾水，完全不知道如何下手。后来发现这个工程有一个<strong>自动化测试文件（test_test.go）</strong>,每部分实验都会使用这个测试文件里的函数对代码进行测试。我们只要顺着这个测试函数逐步倒推，然后补全代码即可。       </p><h2 id="Part-I-Map-Reduce-input-and-output"><a href="#Part-I-Map-Reduce-input-and-output" class="headerlink" title="Part I: Map/Reduce input and output"></a>Part I: Map/Reduce input and output</h2><p>第一部分是先实现一个顺序版（sequential）的MR，让我们对 MR 的流程有一个大体的认识,并且实现<code>doMap()</code> 和 <code>doReduce()</code> 两个函数。<br>其包含两个测试函数<code>TestSequentialSingle()</code> 和 <code>TestSequentialMany()</code>。</p><h3 id="TestSequentialSingle"><a href="#TestSequentialSingle" class="headerlink" title="TestSequentialSingle()"></a>TestSequentialSingle()</h3><p>每个map worker处理一个文件，所以map worker的数量就等于文件的数量。<br>测试单个map worker 和 reduce worker。<br><figure class="highlight golang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestSequentialSingle</span><span class="params">(t *testing.T)</span></span> &#123;</span><br><span class="line">mr := Sequential(<span class="string">"test"</span>, makeInputs(<span class="number">1</span>), <span class="number">1</span>, MapFunc, ReduceFunc)</span><br><span class="line">mr.Wait()</span><br><span class="line">check(t, mr.files)</span><br><span class="line">checkWorker(t, mr.stats)</span><br><span class="line">cleanup(mr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="TestSequentialMany（）"><a href="#TestSequentialMany（）" class="headerlink" title="TestSequentialMany（）"></a>TestSequentialMany（）</h3><p>此测试函数测试多个 map worker 和多个 reduce worker。<br>其运行逻辑和<code>TestSequentialSingle</code>类似。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">func TestSequentialMany(t *testing.T) &#123;</span><br><span class="line">mr := Sequential(&quot;test&quot;, makeInputs(5), 3, MapFunc, ReduceFunc)</span><br><span class="line">mr.Wait()</span><br><span class="line">check(t, mr.files)</span><br><span class="line">checkWorker(t, mr.stats)</span><br><span class="line">cleanup(mr)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="Sequential"><a href="#Sequential" class="headerlink" title="Sequential()"></a>Sequential()</h3><p>测试函数将<code>工作名称，测试文件，reduce 的数量，用户定义的 map 函数，reduce 函数</code>五个实参传递给<code>Sequential()</code></p><pre><code>// Sequential runs map and reduce tasks sequentially, waiting for each task to// complete before running the next.func Sequential(jobName string, files []string, nreduce int,    mapF func(string, string) []KeyValue,    reduceF func(string, []string) string,) (mr *Master) {    mr = newMaster(&quot;master&quot;)    go mr.run(jobName, files, nreduce, func(phase jobPhase) {        switch phase {        case mapPhase:            for i, f := range mr.files {                doMap(mr.jobName, i, f, mr.nReduce, mapF)            }        case reducePhase:            for i := 0; i &lt; mr.nReduce; i++ {                doReduce(mr.jobName, i, mergeName(mr.jobName, i), len(mr.files), reduceF)            }        }    }, func() {        mr.stats = []int{len(files) + nreduce}    })    return}</code></pre><p><code>Sequential()</code>首先获取一个<code>Master</code>    对象的指针，然后利用函数闭包运行<code>Master.run()</code>。</p><h3 id="Master-run"><a href="#Master-run" class="headerlink" title="Master.run()"></a>Master.run()</h3><pre><code>// run executes a mapreduce job on the given number of mappers and reducers.//// First, it divides up the input file among the given number of mappers, and// schedules each task on workers as they become available. Each map task bins// its output in a number of bins equal to the given number of reduce tasks.// Once all the mappers have finished, workers are assigned reduce tasks.//// When all tasks have been completed, the reducer outputs are merged,// statistics are collected, and the master is shut down.//// Note that this implementation assumes a shared file system.func (mr *Master) run(jobName string, files []string, nreduce int,    schedule func(phase jobPhase),    finish func(),) {    mr.jobName = jobName    mr.files = files    mr.nReduce = nreduce    fmt.Printf(&quot;%s: Starting Map/Reduce task %s\n&quot;, mr.address, mr.jobName)    schedule(mapPhase)    schedule(reducePhase)    finish()    mr.merge()    fmt.Printf(&quot;%s: Map/Reduce task completed\n&quot;, mr.address)    mr.doneChannel &lt;- true}</code></pre><h3 id="doMap"><a href="#doMap" class="headerlink" title="doMap()"></a>doMap()</h3><p><code>doMap()</code> 和 <code>doReduce()</code>是需要我们去实现的函数。<br><code>doMap()</code>的实现主要是将用户定义的<code>MapFunc()</code>切割的文本，通过 hash 分到 ‘nReduce’个切片中去。</p><pre><code>func doMap(    jobName string, // the name of the MapReduce job    mapTaskNumber int, // which map task this is    inFile string,    nReduce int, // the number of reduce task that will be run (&quot;R&quot; in the paper)    mapF func(file string, contents string) []KeyValue,) {    // read contents from &apos;infile&apos;    dat,err := ioutil.ReadFile(inFile)    if err != nil {        log.Fatal(&quot;doMap: readFile &quot;, err)    }    //transfer data into ‘kvSlice’ according to the mapF()    kvSlice := mapF(inFile, string(dat))    //divide the ‘kvSlice’ into &apos;reduceKv&apos; according to the ihash()    var reduceKv [][]KeyValue // temporary variable which will be written into reduce files    for i:=0;i&lt;nReduce;i++ {        s1 := make([]KeyValue,0)        reduceKv = append(reduceKv, s1)    }    for _,kv := range kvSlice{        hash := ihash(kv.Key) % nReduce        reduceKv[hash] = append(reduceKv[hash],kv)    }    //write &apos;reduceKv&apos; into ‘nReduce’ JSON files    for i := 0;i&lt;nReduce;i++ {        file,err := os.Create(reduceName(jobName,mapTaskNumber,i))        if err != nil {            log.Fatal(&quot;doMap: create &quot;, err)        }        enc := json.NewEncoder(file)        for _, kv := range reduceKv[i]{            err := enc.Encode(&amp;kv)            if err != nil {                log.Fatal(&quot;doMap: json encodem &quot;, err)            }        }        file.Close()    }}</code></pre><h3 id="doReduce"><a href="#doReduce" class="headerlink" title="doReduce()"></a>doReduce()</h3><p><code>doReduce()</code>主要是将 key 值相同的 value 打包发送给用户定义的 <code>ReduceFunc()</code>，获得一个新的 kv对，key 值不变，而value值则是<code>ReduceFunc()</code>的返回值，排序，最后将新的 kv对 切片写入文件。</p><pre><code>type ByKey []KeyValuefunc (a ByKey) Len() int { return len(a) }func (a ByKey) Swap(i, j int) { a[i],a[j] = a[j],a[i] }func (a ByKey) Less(i, j int) bool { return a[i].Key &lt; a[j].Key }func doReduce(    jobName string, // the name of the whole MapReduce job    reduceTaskNumber int, // which reduce task this is    outFile string, // write the output here    nMap int, // the number of map tasks that were run (&quot;M&quot; in the paper)    reduceF func(key string, values []string) string,) {    //read kv slice from the json file    var kvSlice []KeyValue    for i := 0;i&lt;nMap;i++{        //file, _ := os.OpenFile(reduceName(jobName,i,reduceTaskNumber), os.O_RDONLY, 0666)        file,err := os.Open(reduceName(jobName,i,reduceTaskNumber))        if err != nil {            log.Fatal(&quot;doReduce: open &quot;, err)        }        var kv KeyValue        dec := json.NewDecoder(file)        for{            err := dec.Decode(&amp;kv)            kvSlice = append(kvSlice,kv)            if err == io.EOF {                break            }        }        file.Close()        /********/        //此处如果用 defer，可能会造成文件开启过多，造成程序崩溃        /********/    }    //sort the intermediate kv slices by key    sort.Sort(ByKey(kvSlice))    //process kv slices in the reduceF()    var reduceFValue []string    var outputKv []KeyValue    var preKey string = kvSlice[0].Key    for i,kv := range kvSlice{        if i == (len(kvSlice) - 1) {            reduceFValue = append(reduceFValue, kv.Value)            outputKv = append(outputKv, KeyValue{preKey, reduceF(preKey, reduceFValue)})        } else {                if kv.Key != preKey {                    outputKv = append(outputKv, KeyValue{preKey, reduceF(preKey, reduceFValue)})                    reduceFValue = make([]string, 0)                }                reduceFValue = append(reduceFValue, kv.Value)        }        preKey = kv.Key    }    //write the reduce output as JSON encoded kv objects to the file named outFile    file,err := os.Create(outFile)    if err != nil {        log.Fatal(&quot;doRuduce: create &quot;, err)    }    defer file.Close()    enc := json.NewEncoder(file)    for _, kv := range outputKv{        err := enc.Encode(&amp;kv)        if err != nil {            log.Fatal(&quot;doRuduce: json encode &quot;, err)        }    }}</code></pre><h2 id="Part-II-Single-worker-word-count"><a href="#Part-II-Single-worker-word-count" class="headerlink" title="Part II: Single-worker word count"></a>Part II: Single-worker word count</h2><p>第二部分是实现<code>mapF()</code> 和 <code>reduceF()</code>函数，来实现通过顺序 MR统计词频的功能。<br>比较简单，就直接放代码了。</p><pre><code>func mapF(filename string, contents string) []mapreduce.KeyValue {    f := func(c rune) bool {        return !unicode.IsLetter(c)    }    var strSlice []string = strings.FieldsFunc(contents,f)    var kvSlice []mapreduce.KeyValue    for _,str := range strSlice {        kvSlice = append(kvSlice, mapreduce.KeyValue{str, &quot;1&quot;})    }    return kvSlice}func reduceF(key string, values []string) string {    var cnt int64    for _,str := range values{        temp,err := strconv.ParseInt(str,10,64)        if(err != nil){            fmt.Println(&quot;wc :parseint &quot;,err)        }        cnt += temp    }    return strconv.FormatInt(cnt,10)}</code></pre><h2 id="Part-III-Distributing-MapReduce-tasks-amp-amp-Part-IV-Handling-worker-failures"><a href="#Part-III-Distributing-MapReduce-tasks-amp-amp-Part-IV-Handling-worker-failures" class="headerlink" title="Part III: Distributing MapReduce tasks &amp;&amp; Part IV: Handling worker failures"></a>Part III: Distributing MapReduce tasks &amp;&amp; Part IV: Handling worker failures</h2><p>第三部分和第四部分可以一起来做，主要是完成<code>schedule()</code>，实现一个通过线程并发执行 map worker 和 reduce worker 的 MR 框架。框架通过 RPC 来模拟分布式计算，并要带有 worker 的容灾功能。    </p><h3 id="TestBasic"><a href="#TestBasic" class="headerlink" title="TestBasic()"></a>TestBasic()</h3><p>测试函数启动两个线程运行<code>RUnWoker()</code>。   </p><pre><code>func TestBasic(t *testing.T) {    mr := setup()    for i := 0; i &lt; 2; i++ {        go RunWorker(mr.address, port(&quot;worker&quot;+strconv.Itoa(i)),            MapFunc, ReduceFunc, -1)    }    mr.Wait()    check(t, mr.files)    checkWorker(t, mr.stats)    cleanup(mr)}</code></pre><h3 id="setup-amp-amp-Distributed"><a href="#setup-amp-amp-Distributed" class="headerlink" title="setup() &amp;&amp; Distributed()"></a>setup() &amp;&amp; Distributed()</h3><pre><code>func setup() *Master {    files := makeInputs(nMap)    master := port(&quot;master&quot;)    mr := Distributed(&quot;test&quot;, files, nReduce, master)    return mr}</code></pre><p>通过<code>mr.startRPCServer()</code> 启动 master 的 RPC 服务器，然后通过 <code>mr.run()</code>进行 worker 的调度。</p><pre><code>// Distributed schedules map and reduce tasks on workers that register with the// master over RPC.func Distributed(jobName string, files []string, nreduce int, master string) (mr *Master) {    mr = newMaster(master)    mr.startRPCServer()    go mr.run(jobName, files, nreduce,        func(phase jobPhase) {            ch := make(chan string)            go mr.forwardRegistrations(ch)            schedule(mr.jobName, mr.files, mr.nReduce, phase, ch)        },        func() {            mr.stats = mr.killWorkers()            mr.stopRPCServer()        })    return}</code></pre><h3 id="Master-forwardRegistrations"><a href="#Master-forwardRegistrations" class="headerlink" title="Master.forwardRegistrations()"></a>Master.forwardRegistrations()</h3><p>该函数通过worker 的数量来判断是否有新 worker 启动，一旦发现有新的 worker 启动，则使用管道（ch）通知<code>schedule()</code>。<br>理解该函数对实现后面的<code>schedule()</code>至关重要。</p><pre><code>// helper function that sends information about all existing// and newly registered workers to channel ch. schedule()// reads ch to learn about workers.func (mr *Master) forwardRegistrations(ch chan string) {    i := 0    for {        mr.Lock()        if len(mr.workers) &gt; i {            // there&apos;s a worker that we haven&apos;t told schedule() about.            w := mr.workers[i]            go func() { ch &lt;- w }() // send without holding the lock.            i = i + 1        } else {            // wait for Register() to add an entry to workers[]            // in response to an RPC from a new worker.            mr.newCond.Wait()        }        mr.Unlock()    }}</code></pre><h3 id="schedule"><a href="#schedule" class="headerlink" title="schedule()"></a>schedule()</h3><p><code>shedule()</code>虽然不长，但实现起来还是有点难度的。<br><code>waitGroup</code>用来判断任务是否完成。<br><code>registerChan</code>来监听是否有新的 worker 启动，如果有的话，就启动一个线程来运行该 worker。通过新开线程来运行新 worker的逻辑比较符合分布式 MR 的特点。<br>对于 宕掉的worker执行<code>call()</code>操作时，会返回<code>false</code>。<br>每开始执行一个任务，就让<code>waitGroup</code>减一，而执行失败（<code>call()</code>返回 <code>false</code>）则将<code>waitGroup</code>加一，代表会将该任务安排给其他 worker。     </p><p><code>waitGroup.Wait()</code>则会等到任务完全执行完返回。</p><pre><code>func schedule(jobName string, mapFiles []string, nReduce int, phase jobPhase, registerChan chan string) {    var ntasks int    var n_other int // number of inputs (for reduce) or outputs (for map)    switch phase {    case mapPhase:        ntasks = len(mapFiles)        n_other = nReduce    case reducePhase:        ntasks = nReduce        n_other = len(mapFiles)    }    fmt.Printf(&quot;Schedule: %v %v tasks (%d I/Os)\n&quot;, ntasks, phase, n_other)    // All ntasks tasks have to be scheduled on workers, and only once all of    // them have been completed successfully should the function return.    // Remember that workers may fail, and that any given worker may finish    // multiple tasks.    waitGroup := sync.WaitGroup{}    waitGroup.Add(ntasks)    taskChan := make(chan int, ntasks)    for i:=0;i&lt;ntasks;i++  {        taskChan &lt;- i    }    go func() {        for {            ch := &lt;- registerChan            go func(c string) {                for {                    i := &lt;- taskChan                    if call(c,&quot;Worker.DoTask&quot;, &amp;DoTaskArgs{jobName,                        mapFiles[i],phase,i,n_other},new(struct{})){                        waitGroup.Done()                    } else{                        taskChan &lt;- i                    }                }            }(ch)        }    }()    waitGroup.Wait()    fmt.Printf(&quot;Schedule: %v phase done\n&quot;, phase)}</code></pre><h3 id="RunWorker"><a href="#RunWorker" class="headerlink" title="RunWorker()"></a>RunWorker()</h3><p>通过<code>RunWorker()</code> 来增加 worker。<br><code>nRPC</code>来控制 worker 的寿命，每接收一次 rpc 请求就 -1s。如果初始值为 -1，则代表改 worker 是永生的。</p><pre><code>// RunWorker sets up a connection with the master, registers its address, and// waits for tasks to be scheduled.func RunWorker(MasterAddress string, me string,    MapFunc func(string, string) []KeyValue,    ReduceFunc func(string, []string) string,    nRPC int,) {    debug(&quot;RunWorker %s\n&quot;, me)    wk := new(Worker)    wk.name = me    wk.Map = MapFunc    wk.Reduce = ReduceFunc    wk.nRPC = nRPC    rpcs := rpc.NewServer()    rpcs.Register(wk)    os.Remove(me) // only needed for &quot;unix&quot;    l, e := net.Listen(&quot;unix&quot;, me)    if e != nil {        log.Fatal(&quot;RunWorker: worker &quot;, me, &quot; error: &quot;, e)    }    wk.l = l    wk.register(MasterAddress)    // DON&apos;T MODIFY CODE BELOW    for {        wk.Lock()        if wk.nRPC == 0 {            wk.Unlock()            break        }        wk.Unlock()        conn, err := wk.l.Accept()        if err == nil {            wk.Lock()            wk.nRPC--            wk.Unlock()            go rpcs.ServeConn(conn)        } else {            break        }    }    wk.l.Close()    debug(&quot;RunWorker %s exit\n&quot;, me)}</code></pre><h2 id="Part-V-Inverted-index-generation"><a href="#Part-V-Inverted-index-generation" class="headerlink" title="Part V: Inverted index generation"></a>Part V: Inverted index generation</h2><p>第五部分是实现倒排索引。此处要求的倒排索引，就是在输出结果时，需要将出现过 key 值文件的文件名在 key 值后面输出。<br>功能是通过完成 <code>mapF()</code> 和 <code>reduceF()</code> 来实现的。  </p><h3 id="mapF"><a href="#mapF" class="headerlink" title="mapF()"></a>mapF()</h3><p>将key 值所在文件的文件名赋给 kv对 的value。</p><pre><code>func mapF(document string, value string) (res []mapreduce.KeyValue) {    f := func(c rune) bool {        return !unicode.IsLetter(c)    }    var strSlice []string = strings.FieldsFunc(value,f)    var kvSlice []mapreduce.KeyValue    for _,str := range strSlice {        kvSlice = append(kvSlice, mapreduce.KeyValue{str, document})    }    return kvSlice}</code></pre><h3 id="reduceF"><a href="#reduceF" class="headerlink" title="reduceF()"></a>reduceF()</h3><p>将相同 key 值的所有 value 打包并统计数量返回。</p><pre><code>func reduceF(key string, values []string) string {    var cnt int64    var documents string    set := make(map[string]bool)    for _,str := range values{        set[str] = true    }    var keys []string    for key := range set{        if set[key] == false{            continue        }        keys = append(keys,key)    }    sort.Strings(keys)    for _,key := range keys{        cnt++        if cnt &gt;= 2{            documents += &quot;,&quot;        }        documents += key    }    //return strconv.FormatInt(cnt,10)    return strconv.FormatInt(cnt,10) + &quot; &quot; + documents}</code></pre><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>从刚开始的无从下手，到现在通过Lab1全部测试，MR 实验算是完全做完了，还是很有成就感的。<br>除了对 MR 有一个更深的理解之外，也深深感受到了优秀系统的魅力——功能强大，结构简洁。<br>同时又了解了一门新语言——GoLang，一门专门为高并发系统而设计的语言，用起来还是很舒服的。<br>但这毕竟是分布式系统的第一个实验，欠缺的知识还很多，继续努力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;MIT6.824 是我在学习一些分布式系统方面的知识的时候偶然看到的，然后就开始尝试跟课。不得不说，国外的课程难度是真的大，一周的时间居然要
      
    
    </summary>
    
      <category term="计算机" scheme="http://www.yufengli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
      <category term="操作系统" scheme="http://www.yufengli.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="分布式系统" scheme="http://www.yufengli.cn/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="MIT6.824" scheme="http://www.yufengli.cn/tags/MIT6-824/"/>
    
      <category term="MapReduce" scheme="http://www.yufengli.cn/tags/MapReduce/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://www.yufengli.cn/2018/06/06/hello-world/"/>
    <id>http://www.yufengli.cn/2018/06/06/hello-world/</id>
    <published>2018-06-06T06:02:25.000Z</published>
    <updated>2018-06-06T07:03:25.218Z</updated>
    
    <content type="html"><![CDATA[<p>这篇随笔就用来总结一下自己最近的生活，谈谈自己对未来的想法好了。作为博客的第一篇文章，名字就叫 Hello World 了。</p><h2 id="搭建博客"><a href="#搭建博客" class="headerlink" title="搭建博客"></a>搭建博客</h2><p>之前一直是在 CSDN 上写博客，CSDN 虽然使用简单方便，但是广告太多，界面也有些简陋，用起来不是很舒服。所以我就想着自己搭一个好了，还能记录一些非技术性的东西（主要是最近在养伤，算是比较闲，就想折腾一下）。其实之前是有一个基于 Github Page 的博客的，但是上一个Github 账号删除的时候忘记保存，博客也就没了= =。</p><h2 id="专业方向"><a href="#专业方向" class="headerlink" title="专业方向"></a>专业方向</h2><p>从去年12月乌鲁木齐站结束到现在，ACM-ICPC 生活结束已经半年了。之前打 ACM-ICPC 的时候，不用想太多，就好好刷题，好好准备比赛和期末考试就好了。但 ACM-ICPC比赛总归是一道道的题，将来无论是工作还是深造，还是要落实到工程或者科研上的。所以这半年我也尝试不少新东西，寻找一下自己感兴趣的方向。很多人都说打 ACM-ICPC的算法好，退役后肯定是继续学像机器学习这样人工智能的东西，将来做一个高大上的算法工程师啊。确实，像人工智能算法做的好的话，价值还是很大的。但是我对纯算法的工作好像并不感兴趣，我更偏爱开发方面的工作，喜欢做偏计算机，而不是数学方向的工作。所以我未来理想的工作，是希望能够进入一个纯技术，像中间件， 云计算这样的团队进行底层系统的开发。<br>&lt;!–&gt;</p><h2 id="挂实习"><a href="#挂实习" class="headerlink" title="挂实习"></a>挂实习</h2><p>现在大三，面临着工作还是读研的问题。其实刚上大学的时候，是希望毕业就去工作的。那时候自信满满，觉得自己努力三年，绝对会在毕业斩获无数 offer。但是现实无情打脸，连实习都没找到= =（话说，ACM-ICPC银牌在找工作，尤其是开发方面的工作的时候，作用好像挺小的，估计主要还是我工程方面知识是在太差了，但银牌起码过 BAT 的简历应该没问题）。AT 两家跪掉之后，发现自己工程方面的知识不是一两天能突击回来的，就不想再找实习了，便专心保研了。  </p><h2 id="保研"><a href="#保研" class="headerlink" title="保研"></a>保研</h2><p>前一段时间对保研这件事耿耿于怀，总担心自己上不了好学校。但是在养伤期间（蓝桥杯归途出了些意外，头部缝了n针）心态也逐渐放平和了。我将来并不想走科研的道路，打算硕士毕业就工作了，所以学校的影响好像并不大。况且最差也是保本校，窝工虽然不上什么顶尖学校，但好歹也是双一流，应该不至于有学历歧视吧。所以不管去哪读书，只要方向合适，导师和善，我都能接受。</p><h2 id="尾语"><a href="#尾语" class="headerlink" title="尾语"></a>尾语</h2><blockquote><p>一个人的命运啊,既要考虑历史的进程,也要靠个人的奋斗!</p></blockquote><p>希望自己能保持对技术的热情，在这样一个互联网的时代中留下一些属于自己的痕迹吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这篇随笔就用来总结一下自己最近的生活，谈谈自己对未来的想法好了。作为博客的第一篇文章，名字就叫 Hello World 了。&lt;/p&gt;
&lt;h2 id=&quot;搭建博客&quot;&gt;&lt;a href=&quot;#搭建博客&quot; class=&quot;headerlink&quot; title=&quot;搭建博客&quot;&gt;&lt;/a&gt;搭建博客
      
    
    </summary>
    
      <category term="随笔" scheme="http://www.yufengli.cn/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="生活" scheme="http://www.yufengli.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
</feed>
