<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[CSAPP Lab1-datalab]]></title>
    <url>%2F2018%2F06%2F06%2Fcsapp-lab1%2F</url>
    <content type="text"><![CDATA[前言CSAPP 这本书可以说是程序员必读专业书籍了。这本书以一个 “Hello World” C语言程序为起点，通过跟踪整个”Hello World”程序的生命周期，来讲解系统为了执行该程序都做了哪些事情。就像书名一样，学习本书，能让我们对计算机系统有一个更深入的理解。在学长的推荐下，我开始啃 CSAPP（《深入理解计算机系统》） 这本书，读了前两章，感觉难度还是不小的，但收获也是挺多的，尤其是 “计算机抽象等级” 和 “浮点数” 这两块知识，学了之后有种豁然开朗的感觉。 这本书还有一个特点就是配套的几个实验了，俗话说“纸上得来终觉浅”，配合着实验食用这本书，真是嘎嘣脆，事半功倍。Lab1 对应的就是第二章的知识点，写起来挑战性还是很大的。 Lab1 SolutionLab1 主要就是用 C 语言在一些操作限制的情况下实现题目要求。主要的限制是操作符和操作数。还有一点要注意的就是变量的声明必须放在函数的最前面。整个实验还是很有难度的，我们除了要对正数，浮点数二进制运算要非常熟悉外，还有很多 trick需要我们去思考，毕竟操作数是有限的，我们进行操作的时候要尽可能的“节约”。每写完一道题都可以用 btest 测试一下，但是这个只能测试结果是否正确，操作是否合规无法测试。在所有题目都完成后，可以运行 Driver.pl 对程序进行一个完整的测试，如果能得到所有的分数，那么恭喜你，这个实验就算是圆满完成了。（当然如果想追求极致，可以尝试用更少的操作数来完成实验) bitAndx&amp;y = ~~(x&amp;y) = ~(~x|~y) 12345678910/* * bitAnd - x&amp;y using only ~ and | * Example: bitAnd(6, 5) = 4 * Legal ops: ~ | * Max ops: 8 * Rating: 1 */int bitAnd(int x, int y) &#123; return ~(~x | ~y);&#125; getByte将要取出的八位移动到最右端，并和 0xff 做且运算。 1234567891011/* * getByte - Extract byte n from word x * Bytes numbered from 0 (LSB) to 3 (MSB) * Examples: getByte(0x12345678,1) = 0x56 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 6 * Rating: 2 */int getByte(int x, int n) &#123; return (x &gt;&gt; (n &lt;&lt; 3)) &amp; 0xff;&#125; logicalShift先进行算数右移，再将补充的高位置为0。 123456789101112/* * logicalShift - shift x to the right by n, using a logical shift * Can assume that 0 &lt;= n &lt;= 31 * Examples: logicalShift(0x87654321,4) = 0x08765432 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 20 * Rating: 3 */int logicalShift(int x, int n) &#123; int result = (x &gt;&gt; n) &amp; (~(((1 &lt;&lt; 31) &gt;&gt; n) &lt;&lt; 1)); return result;&#125; bitCount这道题是难度最大的一道了。我们需要用二分的思想，先两位两位地统计1的个数，并将答案存在这两位上。然后四位四位地统计，接着是八位，直到统计完三十二位。统计的时候运用错位相加的方法，需要注意的是在移位之前要将无关位置0，以免无关位相加对结果造成影响。 12345678910111213141516171819202122/* * bitCount - returns count of number of 1's in word * Examples: bitCount(5) = 2, bitCount(7) = 3 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 40 * Rating: 4 */int bitCount(int x) &#123; int tmp = 0x55 | (0x55 &lt;&lt; 8); int mask1 = tmp | (tmp &lt;&lt; 16); int tmp1 = 0x33 | (0x33 &lt;&lt; 8); int mask2 = tmp1 | (tmp1 &lt;&lt; 16); int tmp2 = 0x0f | (0x0f &lt;&lt; 8); int mask3 = tmp2 | (tmp2 &lt;&lt; 16); x = (x &amp; mask1) + ((x &gt;&gt; 1) &amp; mask1); x = (x &amp; mask2) + ((x &gt;&gt; 2) &amp; mask2); x = (x &amp; mask3) + ((x &gt;&gt; 4) &amp; mask3); x = x + (x &gt;&gt; 8); x = x + (x &gt;&gt; 16); return x &amp; 0x3f;&#125; bang如果x是0的话，~0|0的符号位仍为0；x非0的话，~x|x 的符号位为1。 12345678910111213/* * bang - Compute !x without using ! * Examples: bang(3) = 0, bang(0) = 1 * Legal ops: ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 12 * Rating: 4 */int bang(int x) &#123; int minusx = ~x + 1; int sign = (x | minusx) &gt;&gt; 31; return (~sign) &amp; 0x1;&#125; tmin久违的送分题。 123456789/* * tmin - return minimum two's complement integer * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 4 * Rating: 1 */int tmin(void) &#123; return 1 &lt;&lt; 31;&#125; fitsBits这道题需要注意的就是符号位了。之所以向移动 (32-n) 位，而不是 (31-n) 位就是为了留出符号位。 12345678910111213/* * fitsBits - return 1 if x can be represented as an * n-bit, two's complement integer. * 1 &lt;= n &lt;= 32 * Examples: fitsBits(5,3) = 0, fitsBits(-4,3) = 1 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 2 */int fitsBits(int x, int n) &#123; int shiftNumber = 32 + (~n + 1); return !((x &lt;&lt; shiftNumber &gt;&gt; shiftNumber) ^ x);&#125; divpw2这题难点在于舍入。正数直接右移 n 位即可，负数则需要加一个偏移量再右移。还有一点需要注意的就是掩码的求取了，需要一些技巧，毕竟操作数是有限的，还要节约使用。 1234567891011121314/* * divpwr2 - Compute x/(2^n), for 0 &lt;= n &lt;= 30 * Round toward zero * Examples: divpwr2(15,1) = 7, divpwr2(-33,4) = -2 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 15 * Rating: 2 */int divpwr2(int x, int n) &#123; int signx = x &gt;&gt; 31; int mask = (1 &lt;&lt; n) + (~0); int bias = signx &amp; mask; return (x + bias) &gt;&gt; n; &#125; negate送分题。 12345678910/* * negate - return -x * Example: negate(1) = -1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 5 * Rating: 2 */int negate(int x) &#123; return ~x + 1;&#125; isPositive这道题难点在于0的判断。0有一个非常特殊的性质就是 !0 = 1，利用0的这个特点，此题就不难解出了。 12345678910/* * isPositive - return 1 if x &gt; 0, return 0 otherwise * Example: isPositive(-1) = 0. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 8 * Rating: 3 */int isPositive(int x) &#123; return !((x &gt;&gt; 31) | (!x));&#125; isLessOrEqual这道题相当于枚举 x&lt;=y 的所有情况： x为负数，y 为正数 x 等于 y x 和 y 符号相同，并且 y-x 为正数 123456789101112131415/* * isLessOrEqual - if x &lt;= y then return 1, else return 0 * Example: isLessOrEqual(4,5) = 1. * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 24 * Rating: 3 */int isLessOrEqual(int x, int y) &#123; int signx = (x&gt;&gt;31) &amp; 0x1; int signy = (y&gt;&gt;31) &amp; 0x1; int tmp = signx ^ signy; int tmp1 = tmp &amp; signx; int y_minus_x = y+(~x+1); return tmp1 | (!(x^y)) | (!tmp &amp; !(y_minus_x&amp;(1 &lt;&lt; 31)));&#125; ilgo2求以2为底，x 的对数。这道题算是难题之一了，其原理和 bitCount 有些类似，都是用二分的思想，但这道题是求出最高位的1。通过二分整数的所有位，找出最高位1的位置。 12345678910111213141516/* * ilog2 - return floor(log base 2 of x), where x &gt; 0 * Example: ilog2(16) = 4 * Legal ops: ! ~ &amp; ^ | + &lt;&lt; &gt;&gt; * Max ops: 90 * Rating: 4 */int ilog2(int x) &#123; int bitsNumber = 0; bitsNumber = (!!(x &gt;&gt; 16)) &lt;&lt; 4; bitsNumber += (!!(x &gt;&gt; (bitsNumber + 8)) &lt;&lt; 3); bitsNumber += (!!(x &gt;&gt; (bitsNumber + 4)) &lt;&lt; 2); bitsNumber += (!!(x &gt;&gt; (bitsNumber + 2)) &lt;&lt; 1); bitsNumber += (!!(x &gt;&gt; (bitsNumber + 1))); return bitsNumber;&#125; float_neg从这道题开始就进入了浮点数的练习，这部分需要我们对 IEEE 浮点数编码先回顾一下。这道题难点就在于 NaN 的判断，如果 uf 是 NaN，需要原值返回。 12345678910111213141516171819/* * float_neg - Return bit-level equivalent of expression -f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representations of * single-precision floating point values. * When argument is NaN, return argument. * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 10 * Rating: 2 */unsigned float_neg(unsigned uf) &#123; unsigned result = uf ^ (1 &lt;&lt; 31); int tmp = 0xff &lt;&lt; 23; if((uf &amp; (tmp|(0xff &lt;&lt; 15)|(0xff &lt;&lt; 7)|0xff)) &gt; tmp)&#123; result = uf; &#125; return result;&#125; float_i2f这道题完全就是考察队 IEEE 浮点数编码的熟悉程度了。第一遍写的时候怎么都过不了，后来发现是望考虑舍入了。除此之外这道题操作数也是一个难点，需要用到不少小 trick 来精简操作数。 123456789101112131415161718192021222324252627282930313233343536373839404142434445/* * float_i2f - Return bit-level equivalent of expression (float) x * Result is returned as unsigned int, but * it is to be interpreted as the bit-level representation of a * single-precision floating point values. * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */unsigned float_i2f(int x) &#123; int first1 = 31; int frac = 0; int flag = 0; unsigned tmp = 0; int exp = 0; int mask = (0xff &lt;&lt; 15)|(0xff &lt;&lt; 7)|(0x7f); int mask1 = 1 &lt;&lt; 31; int sign = x &amp; mask1; if(x &lt; 0)&#123; x = -x; &#125; if(x == 0) return 0; if(x &gt; 0)&#123; while(!(x &gt;&gt; first1))&#123; first1 = first1 - 1; &#125; if(first1 &gt; 23)&#123; frac = (x &gt;&gt; (first1 - 23)) &amp; mask; tmp = x &lt;&lt; (55 - first1); if(tmp &gt; mask1) flag = 1; else if(tmp == mask1)&#123; if(frac &amp; 0x1) flag = 1; &#125; &#125; else&#123; frac = (x &lt;&lt; (23 - first1)) &amp; mask; &#125; &#125; exp = 127 + first1; return sign + (exp &lt;&lt; 23) + frac + flag;&#125; float_twice最后一道题是浮点数二倍乘。无穷大和 NaN 就直接返回原值就好，规格化数阶码直接加1，非规格化数尾数左移一位（移位后可能变为规格化数，但这并不影响答案，这也正是 IEEE 浮点数编码的巧妙之处，不用担心)。 12345678910111213141516171819202122232425/* * float_twice - Return bit-level equivalent of expression 2*f for * floating point argument f. * Both the argument and result are passed as unsigned int's, but * they are to be interpreted as the bit-level representation of * single-precision floating point values. * When argument is NaN, return argument * Legal ops: Any integer/unsigned operations incl. ||, &amp;&amp;. also if, while * Max ops: 30 * Rating: 4 */unsigned float_twice(unsigned uf) &#123; int mask1 = 0xff &lt;&lt; 23; unsigned result = 0; if((uf &amp; mask1) == mask1)&#123; result = uf; &#125; else if((uf &amp; mask1) == 0x0)&#123; result = (uf &amp; (1 &lt;&lt; 31)) | (uf &lt;&lt; 1); &#125; else&#123; result = uf + (1 &lt;&lt; 23); &#125; return result;&#125; 后记之前只知道浮点数有误差，但并不知其所以然。有些数，比如0.1是无法用浮点数准确表示的，只能近似表示。int转 float，long long 转 double 由于尾数限制，也都会被舍入。总的来说，浮点数的精度由尾数位数决定，范围是由阶码位数决定的。 CSAPP 这本书真的不错，无论是书上的知识还是实验的内容干货都非常的多。学了前两章，收获还是挺大的，尤其是整数和浮点数的二进制表示这部分知识。但是感觉进度实在是太慢了，按照现在的速度，今年都不一定把这本书看完= =，接下来还是提高效率，抓紧时间把这本书啃完吧。]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>深入理解计算机系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MIT6.824 Lab1-MapReduce]]></title>
    <url>%2F2018%2F06%2F06%2Fmit6-824-lab1%2F</url>
    <content type="text"><![CDATA[前言MIT6.824 是我在学习一些分布式系统方面的知识的时候偶然看到的，然后就开始尝试跟课。不得不说，国外的课程难度是真的大，一周的时间居然要学一门 Go 语言，然后还要读论文，进而做MapReduce 实验。由于 MR（MapReduce） 框架需要建立在 DFS（Distributed File System）的基础上实现，所以本实验是通过使用多线程来模拟分布式环境。虽然难度上大大降低，但是通过该实验，还是会让我们对 MR 的核心原理有一个较为深刻的认识。做实验之前我们需要先把经典的 MapReduce 论文给看了，窝比较建议直接看英文原文，但如果时间不充裕的话，可以直接在网上找中文的翻译版。刚开始做这个实验的时候真的是一头雾水，完全不知道如何下手。后来发现这个工程有一个自动化测试文件（test_test.go）,每部分实验都会使用这个测试文件里的函数对代码进行测试。我们只要顺着这个测试函数逐步倒推，然后补全代码即可。 Part I: Map/Reduce input and output第一部分是先实现一个顺序版（sequential）的MR，让我们对 MR 的流程有一个大体的认识,并且实现doMap() 和 doReduce() 两个函数。其包含两个测试函数TestSequentialSingle() 和 TestSequentialMany()。 TestSequentialSingle()每个map worker处理一个文件，所以map worker的数量就等于文件的数量。测试单个map worker 和 reduce worker。 1234567func TestSequentialSingle(t *testing.T) &#123; mr := Sequential("test", makeInputs(1), 1, MapFunc, ReduceFunc) mr.Wait() check(t, mr.files) checkWorker(t, mr.stats) cleanup(mr)&#125; TestSequentialMany（）此测试函数测试多个 map worker 和多个 reduce worker。其运行逻辑和TestSequentialSingle类似。 1234567func TestSequentialMany(t *testing.T) &#123; mr := Sequential("test", makeInputs(5), 3, MapFunc, ReduceFunc) mr.Wait() check(t, mr.files) checkWorker(t, mr.stats) cleanup(mr)&#125; Sequential()测试函数将工作名称，测试文件，reduce 的数量，用户定义的 map 函数，reduce 函数五个实参传递给Sequential() 123456789101112131415161718192021222324// Sequential runs map and reduce tasks sequentially, waiting for each task to// complete before running the next.func Sequential(jobName string, files []string, nreduce int, mapF func(string, string) []KeyValue, reduceF func(string, []string) string,) (mr *Master) &#123; mr = newMaster("master") go mr.run(jobName, files, nreduce, func(phase jobPhase) &#123; switch phase &#123; case mapPhase: for i, f := range mr.files &#123; doMap(mr.jobName, i, f, mr.nReduce, mapF) &#125; case reducePhase: for i := 0; i &lt; mr.nReduce; i++ &#123; doReduce(mr.jobName, i, mergeName(mr.jobName, i), len(mr.files), reduceF) &#125; &#125; &#125;, func() &#123; mr.stats = []int&#123;len(files) + nreduce&#125; &#125;) return&#125;`Sequential()`首先获取一个`Master` 对象的指针，然后利用函数闭包运行`Master.run()`。 Master.run()123456789101112131415161718192021222324252627282930// run executes a mapreduce job on the given number of mappers and reducers.//// First, it divides up the input file among the given number of mappers, and// schedules each task on workers as they become available. Each map task bins// its output in a number of bins equal to the given number of reduce tasks.// Once all the mappers have finished, workers are assigned reduce tasks.//// When all tasks have been completed, the reducer outputs are merged,// statistics are collected, and the master is shut down.//// Note that this implementation assumes a shared file system.func (mr *Master) run(jobName string, files []string, nreduce int, schedule func(phase jobPhase), finish func(),) &#123; mr.jobName = jobName mr.files = files mr.nReduce = nreduce fmt.Printf("%s: Starting Map/Reduce task %s\n", mr.address, mr.jobName) schedule(mapPhase) schedule(reducePhase) finish() mr.merge() fmt.Printf("%s: Map/Reduce task completed\n", mr.address) mr.doneChannel &lt;- true&#125; doMap()doMap() 和 doReduce()是需要我们去实现的函数。doMap()的实现主要是将用户定义的MapFunc()切割的文本，通过 hash 分到 ‘nReduce’个切片中去。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124func doMap( jobName string, // the name of the MapReduce job mapTaskNumber int, // which map task this is inFile string, nReduce int, // the number of reduce task that will be run ("R" in the paper) mapF func(file string, contents string) []KeyValue,) &#123; // read contents from 'infile' dat,err := ioutil.ReadFile(inFile) if err != nil &#123; log.Fatal("doMap: readFile ", err) &#125; //transfer data into ‘kvSlice’ according to the mapF() kvSlice := mapF(inFile, string(dat)) //divide the ‘kvSlice’ into 'reduceKv' according to the ihash() var reduceKv [][]KeyValue // temporary variable which will be written into reduce files for i:=0;i&lt;nReduce;i++ &#123; s1 := make([]KeyValue,0) reduceKv = append(reduceKv, s1) &#125; for _,kv := range kvSlice&#123; hash := ihash(kv.Key) % nReduce reduceKv[hash] = append(reduceKv[hash],kv) &#125; //write 'reduceKv' into ‘nReduce’ JSON files for i := 0;i&lt;nReduce;i++ &#123; file,err := os.Create(reduceName(jobName,mapTaskNumber,i)) if err != nil &#123; log.Fatal("doMap: create ", err) &#125; enc := json.NewEncoder(file) for _, kv := range reduceKv[i]&#123; err := enc.Encode(&amp;kv) if err != nil &#123; log.Fatal("doMap: json encodem ", err) &#125; &#125; file.Close() &#125;&#125;``` ### doReduce()`doReduce()`主要是将 key 值相同的 value 打包发送给用户定义的 `ReduceFunc()`，获得一个新的 kv对，key 值不变，而value值则是`ReduceFunc()`的返回值，排序，最后将新的 kv对 切片写入文件。```golangtype ByKey []KeyValuefunc (a ByKey) Len() int &#123; return len(a) &#125;func (a ByKey) Swap(i, j int) &#123; a[i],a[j] = a[j],a[i] &#125;func (a ByKey) Less(i, j int) bool &#123; return a[i].Key &lt; a[j].Key &#125; func doReduce( jobName string, // the name of the whole MapReduce job reduceTaskNumber int, // which reduce task this is outFile string, // write the output here nMap int, // the number of map tasks that were run ("M" in the paper) reduceF func(key string, values []string) string,) &#123; //read kv slice from the json file var kvSlice []KeyValue for i := 0;i&lt;nMap;i++&#123; //file, _ := os.OpenFile(reduceName(jobName,i,reduceTaskNumber), os.O_RDONLY, 0666) file,err := os.Open(reduceName(jobName,i,reduceTaskNumber)) if err != nil &#123; log.Fatal("doReduce: open ", err) &#125; var kv KeyValue dec := json.NewDecoder(file) for&#123; err := dec.Decode(&amp;kv) kvSlice = append(kvSlice,kv) if err == io.EOF &#123; break &#125; &#125; file.Close() /********/ //此处如果用 defer，可能会造成文件开启过多，造成程序崩溃 /********/ &#125; //sort the intermediate kv slices by key sort.Sort(ByKey(kvSlice)) //process kv slices in the reduceF() var reduceFValue []string var outputKv []KeyValue var preKey string = kvSlice[0].Key for i,kv := range kvSlice&#123; if i == (len(kvSlice) - 1) &#123; reduceFValue = append(reduceFValue, kv.Value) outputKv = append(outputKv, KeyValue&#123;preKey, reduceF(preKey, reduceFValue)&#125;) &#125; else &#123; if kv.Key != preKey &#123; outputKv = append(outputKv, KeyValue&#123;preKey, reduceF(preKey, reduceFValue)&#125;) reduceFValue = make([]string, 0) &#125; reduceFValue = append(reduceFValue, kv.Value) &#125; preKey = kv.Key &#125; //write the reduce output as JSON encoded kv objects to the file named outFile file,err := os.Create(outFile) if err != nil &#123; log.Fatal("doRuduce: create ", err) &#125; defer file.Close() enc := json.NewEncoder(file) for _, kv := range outputKv&#123; err := enc.Encode(&amp;kv) if err != nil &#123; log.Fatal("doRuduce: json encode ", err) &#125; &#125;&#125; Part II: Single-worker word count第二部分是实现mapF() 和 reduceF()函数，来实现通过顺序 MR统计词频的功能。比较简单，就直接放代码了。 123456789101112131415161718192021222324func mapF(filename string, contents string) []mapreduce.KeyValue &#123; f := func(c rune) bool &#123; return !unicode.IsLetter(c) &#125; var strSlice []string = strings.FieldsFunc(contents,f) var kvSlice []mapreduce.KeyValue for _,str := range strSlice &#123; kvSlice = append(kvSlice, mapreduce.KeyValue&#123;str, "1"&#125;) &#125; return kvSlice&#125; func reduceF(key string, values []string) string &#123; var cnt int64 for _,str := range values&#123; temp,err := strconv.ParseInt(str,10,64) if(err != nil)&#123; fmt.Println("wc :parseint ",err) &#125; cnt += temp &#125; return strconv.FormatInt(cnt,10)&#125; Part III: Distributing MapReduce tasks &amp;&amp; Part IV: Handling worker failures第三部分和第四部分可以一起来做，主要是完成schedule()，实现一个通过线程并发执行 map worker 和 reduce worker 的 MR 框架。框架通过 RPC 来模拟分布式计算，并要带有 worker 的容灾功能。 TestBasic()测试函数启动两个线程运行RUnWoker()。 1234567891011121314151617181920212223242526272829303132333435363738394041424344func TestBasic(t *testing.T) &#123; mr := setup() for i := 0; i &lt; 2; i++ &#123; go RunWorker(mr.address, port("worker"+strconv.Itoa(i)), MapFunc, ReduceFunc, -1) &#125; mr.Wait() check(t, mr.files) checkWorker(t, mr.stats) cleanup(mr)&#125;``` ### setup() &amp;&amp; Distributed()```golangfunc setup() *Master &#123; files := makeInputs(nMap) master := port("master") mr := Distributed("test", files, nReduce, master) return mr&#125;``` 通过`mr.startRPCServer()` 启动 master 的 RPC 服务器，然后通过 `mr.run()`进行 worker 的调度。```golang// Distributed schedules map and reduce tasks on workers that register with the// master over RPC.func Distributed(jobName string, files []string, nreduce int, master string) (mr *Master) &#123; mr = newMaster(master) mr.startRPCServer() go mr.run(jobName, files, nreduce, func(phase jobPhase) &#123; ch := make(chan string) go mr.forwardRegistrations(ch) schedule(mr.jobName, mr.files, mr.nReduce, phase, ch) &#125;, func() &#123; mr.stats = mr.killWorkers() mr.stopRPCServer() &#125;) return&#125; Master.forwardRegistrations()该函数通过worker 的数量来判断是否有新 worker 启动，一旦发现有新的 worker 启动，则使用管道（ch）通知schedule()。理解该函数对实现后面的schedule()至关重要。 1234567891011121314151617181920// helper function that sends information about all existing// and newly registered workers to channel ch. schedule()// reads ch to learn about workers.func (mr *Master) forwardRegistrations(ch chan string) &#123; i := 0 for &#123; mr.Lock() if len(mr.workers) &gt; i &#123; // there's a worker that we haven't told schedule() about. w := mr.workers[i] go func() &#123; ch &lt;- w &#125;() // send without holding the lock. i = i + 1 &#125; else &#123; // wait for Register() to add an entry to workers[] // in response to an RPC from a new worker. mr.newCond.Wait() &#125; mr.Unlock() &#125;&#125; schedule()shedule()虽然不长，但实现起来还是有点难度的。waitGroup用来判断任务是否完成。registerChan来监听是否有新的 worker 启动，如果有的话，就启动一个线程来运行该 worker。通过新开线程来运行新 worker的逻辑比较符合分布式 MR 的特点。对于 宕掉的worker执行call()操作时，会返回false。每开始执行一个任务，就让waitGroup减一，而执行失败（call()返回 false）则将waitGroup加一，代表会将该任务安排给其他 worker。 waitGroup.Wait()则会等到任务完全执行完返回。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748func schedule(jobName string, mapFiles []string, nReduce int, phase jobPhase, registerChan chan string) &#123; var ntasks int var n_other int // number of inputs (for reduce) or outputs (for map) switch phase &#123; case mapPhase: ntasks = len(mapFiles) n_other = nReduce case reducePhase: ntasks = nReduce n_other = len(mapFiles) &#125; fmt.Printf("Schedule: %v %v tasks (%d I/Os)\n", ntasks, phase, n_other) // All ntasks tasks have to be scheduled on workers, and only once all of // them have been completed successfully should the function return. // Remember that workers may fail, and that any given worker may finish // multiple tasks. waitGroup := sync.WaitGroup&#123;&#125; waitGroup.Add(ntasks) taskChan := make(chan int, ntasks) for i:=0;i&lt;ntasks;i++ &#123; taskChan &lt;- i &#125; go func() &#123; for &#123; ch := &lt;- registerChan go func(c string) &#123; for &#123; i := &lt;- taskChan if call(c,"Worker.DoTask", &amp;DoTaskArgs&#123;jobName, mapFiles[i],phase,i,n_other&#125;,new(struct&#123;&#125;))&#123; waitGroup.Done() &#125; else&#123; taskChan &lt;- i &#125; &#125; &#125;(ch) &#125; &#125;() waitGroup.Wait() fmt.Printf("Schedule: %v phase done\n", phase)&#125; RunWorker()通过RunWorker() 来增加 worker。nRPC来控制 worker 的寿命，每接收一次 rpc 请求就 -1s。如果初始值为 -1，则代表改 worker 是永生的。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// RunWorker sets up a connection with the master, registers its address, and// waits for tasks to be scheduled.func RunWorker(MasterAddress string, me string, MapFunc func(string, string) []KeyValue, ReduceFunc func(string, []string) string, nRPC int,) &#123; debug("RunWorker %s\n", me) wk := new(Worker) wk.name = me wk.Map = MapFunc wk.Reduce = ReduceFunc wk.nRPC = nRPC rpcs := rpc.NewServer() rpcs.Register(wk) os.Remove(me) // only needed for "unix" l, e := net.Listen("unix", me) if e != nil &#123; log.Fatal("RunWorker: worker ", me, " error: ", e) &#125; wk.l = l wk.register(MasterAddress) // DON'T MODIFY CODE BELOW for &#123; wk.Lock() if wk.nRPC == 0 &#123; wk.Unlock() break &#125; wk.Unlock() conn, err := wk.l.Accept() if err == nil &#123; wk.Lock() wk.nRPC-- wk.Unlock() go rpcs.ServeConn(conn) &#125; else &#123; break &#125; &#125; wk.l.Close() debug("RunWorker %s exit\n", me)&#125;``` ## Part V: Inverted index generation第五部分是实现倒排索引。此处要求的倒排索引，就是在输出结果时，需要将出现过 key 值文件的文件名在 key 值后面输出。 功能是通过完成 `mapF()` 和 `reduceF()` 来实现的。 ### mapF()将key 值所在文件的文件名赋给 kv对 的value。```golangfunc mapF(document string, value string) (res []mapreduce.KeyValue) &#123; f := func(c rune) bool &#123; return !unicode.IsLetter(c) &#125; var strSlice []string = strings.FieldsFunc(value,f) var kvSlice []mapreduce.KeyValue for _,str := range strSlice &#123; kvSlice = append(kvSlice, mapreduce.KeyValue&#123;str, document&#125;) &#125; return kvSlice&#125; reduceF()将相同 key 值的所有 value 打包并统计数量返回。 func reduceF(key string, values []string) string { var cnt int64 var documents string set := make(map[string]bool) for _,str := range values{ set[str] = true } var keys []string for key := range set{ if set[key] == false{ continue } keys = append(keys,key) } sort.Strings(keys) for _,key := range keys{ cnt++ if cnt &gt;= 2{ documents += "," } documents += key } //return strconv.FormatInt(cnt,10) return strconv.FormatInt(cnt,10) + " " + documents } 后记从刚开始的无从下手，到现在通过Lab1全部测试，MR 实验算是完全做完了，还是很有成就感的。除了对 MR 有一个更深的理解之外，也深深感受到了优秀系统的魅力——功能强大，结构简洁。同时又了解了一门新语言——GoLang，一门专门为高并发系统而设计的语言，用起来还是很舒服的。但这毕竟是分布式系统的第一个实验，欠缺的知识还很多，继续努力。]]></content>
      <categories>
        <category>计算机</category>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>分布式系统</tag>
        <tag>MIT6.824</tag>
        <tag>MapReduce</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F06%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[这篇随笔就用来总结一下自己最近的生活，谈谈自己对未来的想法好了。作为博客的第一篇文章，名字就叫 Hello World 了。 搭建博客之前一直是在 CSDN 上写博客，CSDN 虽然使用简单方便，但是广告太多，界面也有些简陋，用起来不是很舒服。所以我就想着自己搭一个好了，还能记录一些非技术性的东西（主要是最近在养伤，算是比较闲，就想折腾一下）。其实之前是有一个基于 Github Page 的博客的，但是上一个Github 账号删除的时候忘记保存，博客也就没了= =。 专业方向从去年12月乌鲁木齐站结束到现在，ACM-ICPC 生活结束已经半年了。之前打 ACM-ICPC 的时候，不用想太多，就好好刷题，好好准备比赛和期末考试就好了。但 ACM-ICPC比赛总归是一道道的题，将来无论是工作还是深造，还是要落实到工程或者科研上的。所以这半年我也尝试不少新东西，寻找一下自己感兴趣的方向。很多人都说打 ACM-ICPC的算法好，退役后肯定是继续学像机器学习这样人工智能的东西，将来做一个高大上的算法工程师啊。确实，像人工智能算法做的好的话，价值还是很大的。但是我对纯算法的工作好像并不感兴趣，我更偏爱开发方面的工作，喜欢做偏计算机，而不是数学方向的工作。所以我未来理想的工作，是希望能够进入一个纯技术，像中间件， 云计算这样的团队进行底层系统的开发。&lt;!–&gt; 挂实习现在大三，面临着工作还是读研的问题。其实刚上大学的时候，是希望毕业就去工作的。那时候自信满满，觉得自己努力三年，绝对会在毕业斩获无数 offer。但是现实无情打脸，连实习都没找到= =（话说，ACM-ICPC银牌在找工作，尤其是开发方面的工作的时候，作用好像挺小的，估计主要还是我工程方面知识是在太差了，但银牌起码过 BAT 的简历应该没问题）。AT 两家跪掉之后，发现自己工程方面的知识不是一两天能突击回来的，就不想再找实习了，便专心保研了。 保研前一段时间对保研这件事耿耿于怀，总担心自己上不了好学校。但是在养伤期间（蓝桥杯归途出了些意外，头部缝了n针）心态也逐渐放平和了。我将来并不想走科研的道路，打算硕士毕业就工作了，所以学校的影响好像并不大。况且最差也是保本校，窝工虽然不上什么顶尖学校，但好歹也是双一流，应该不至于有学历歧视吧。所以不管去哪读书，只要方向合适，导师和善，我都能接受。 尾语一个人的命运啊,既要考虑历史的进程,也要靠个人的奋斗! 希望自己能保持对技术的热情，在这样一个互联网的时代中留下一些属于自己的痕迹吧。]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
</search>
